------------------------------------------------------------------------------
HGIMG ver3.5    REFERENCE MANUAL       High Performance Graphic Image Plugin  
ＨＳＰ拡張DLLリファレンス             copyright 2001-2017 (c) onion software  
------------------------------------------------------------------------------

・はじめに

	HGIMG3は、Hot Soup Processor ver3.5以降とともに使用することで、
	画面の描画に関する様々な機能拡張を提供します。
	HGIMG3は、Windows98、Me、2000、XP、Vista、7以降のDirectX8以上が
	インストールされた環境で動作します。
	(Windows XP以降には、標準で含まれているためDirectXインストールの
	必要はありません)


・インストール

	HGIMG3は、以下のようなファイル構成になっています。

		hgimg3.txt (このファイル)
		hsp3hg.exe (実行用ランタイム)

		commonフォルダ (HGIMG3ヘッダファイル)
		hsphelpフォルダ (HGIMG3ヘルプファイル)
		runtimeフォルダ (HGIMG3カスタムランタイム)
		sampleフォルダ (HGIMG3サンプルスクリプト & データ)

	HGIMG3を使用したスクリプトを作成する場合には、スクリプトの先頭に
	必ず「#include "hgimg3.as"」という行を追加してください。
	以上で、HSPの機能が拡張され、このリファレンスで説明をしている命令を
	使用することができるようになります。
	まず最初に、付属のサンプルスクリプトを実行してみてください。
	拡張された機能の簡単な使用例を見ることができるはずです。
	サンプルスクリプトは、HSPインストールフォルダ以下のsample/hgimg3
	に用意されています。


・注意点

	HGIMG3は、外部DLLファイルによる拡張プラグインではありません。
	HSP3.0の機能を内包したランタイムファイルとして提供されています。
	必ず、HGIMG3のランタイムに対応したバージョンのコンパイラ
	(hspcmp.dll)やスクリプトエディタをご使用下さい。
	また、HSP3は実行ランタイムに対応したコードジェネレーター(hspcmp.dll)
	をご使用ください。(HSP3.2以上を推奨)


・著作権とライセンス

	ユーザーがHGIMG3を使って作成したオリジナルのソフトウェア(実行ファイル)の権利は、
	それを作成したユーザーに属します。
	ユーザーがHGIMG3を使って作成したオリジナルのソフトウェア(実行ファイル)を、
	自由に通信、即売会、店頭などで展示、配布、販売することができます。
	ライセンス料は必要ありません。

	ただし、HGIMG3ではOggVorvis形式のファイルデコードにXiph.org Foundation
	のライブラリを使用しており、実行ファイルの配布にあたっては
	規定に従って以下のライセンス表記が必要になります。

	--------------------------------------------------------------------------------
	OggVorvis形式のファイルデコードに以下のライブラリを使用しています
	libvorbis : Copyright (c) 2002-2004 Xiph.org Foundation
	--------------------------------------------------------------------------------
	(配布物の中に上記の内容を含むテキストを含めるようにしてください。)

	HGIMG3ランタイムの著作権はonion softwareにあります。
	onion softwareは本プログラムによって生じた、いかなる損害についても保証いたしません。
	自己の責任の範囲で使用してください。

	HGIMG3ランタイムとそれに付随するサンプルスクリプト・データは、
	基本的にBSDライセンスのもと有償・無償を問わず添付、複製、改編、再配布
	することができます。
	ただし、その際には必ず以下のライセンス表記も含めるようにしてください。
	(これは、ランタイムファイル(.hrt)及びサンプルスクリプト、データを配布
	 する際の表記です。自分の作ったオリジナルのソフトウェア(実行ファイル)を
	配布する際には、上にあるlibvorbisのライセンス表記のみで問題ありません。)

	--------------------------------------------------------------------------------
	HGIMG3 : Made with base technology of OpenHSP
	Copyright (C) 1997-2017, Onion Software/onitama.
	All rights reserved.
	OggVorvis形式のファイルデコードに以下のライブラリを使用しています
	libvorbis : Copyright (c) 2002-2004 Xiph.org Foundation
	--------------------------------------------------------------------------------

	(配布物の中に上記の内容を含むテキストを含めるようにしてください。)


・HGIMG3の概要

	HGIMG3は、高度な2D、3Dグラフィックを使ったアプリケーションをHSPから
	作成するための拡張プラグインです。
	スプライトを使用した2Dゲームから、3Dモデルを使った本格的なソフトまで幅広く
	利用することができます。

	HGIMG3でサポートされる主な機能は以下の通りです。

	・DirectX、フルカラーモードを対象とした高度な描画システム
	・2Dスプライト、3Dポリゴンなどを共通の命令で設定可能な描画エンジン
	・2Dスプライトの回転拡大縮小、α合成、透明色抜き処理、タイリング(BG表示)
	・3D座標上の2Dスプライトと3Dポリゴンを混在可能なワールド管理
	・3Dの階層構造を持ったポリゴンモデルの管理が可能
	・ボーンを用いた3Dワンスキンモデルのアニメーション表示が可能
	・アニメ風のレンダリング(トゥーンシェーディング)表示が可能
	・BMP、JPG、GIF、PNG、DDS、TGA、TIFF形式のテクスチャサポート
	・アンチエイリアスを含めた日本語フォントのテクスチャレンダリング機能
	・アルファチャンネルを含むテクスチャ画像のサポート
	・スプライトの表示、移動の管理および衝突判定機能
	・HSP3に対応した浮動小数によるジオメトリ演算
	・イベントリスト登録機能により自由度の高い自律処理を実現可能
	・単位時間あたりの移動量から動きの計算を行なうタイムスケールモードを搭載
	・DXF形式の3Dデータ読み込みをサポート
	・使いやすい直接描画命令を装備

	主要な命令はVer2.61添付のバージョン(HGIMG2)と互換で動作しますが、
	機能の整理統合により、一部の命令が非互換または廃止となっています。
	また、フラグやモードなど細かい部分が異なっているため、以前のスクリプトを
	移植して利用する場合には修正が必要です。
	逆に、HSP3.0に合わせてより便利に拡張されている部分も多数あります。
	HGIMG2の考え方や命令の仕組みはそのままで、HGIMG3を習得することが
	できるはずですので、是非ともHGIMG3の新機能をご活用ください。

	Ver2.61添付のバージョン(HGIMG2)と比べて以下の機能が削除されています。

	・独自のアニメーション形式(ma)によるモーション再生
	・ポリゴン情報、および階層情報の参照と変更、mx形式でのセーブ
	・画面上の2D位置から該当するポリゴンを検索するポリゴンスキャン機能
	・objmov系のMOCパラメーター自動変更はイベント機能に置き換えせれています
	・フォールオフレンダリング機能は削除されタイムスケールモードが搭載されています

	HGIMG3は、以前のバージョン(HGIMG2)に比べて、機能は増えていますが、
	より習得しやすく、通常使用するための命令数やパラメーターは削減されています。
	初心者から、上級者まで手軽に2D・3Dの高度な機能を活用することを目指して
	設計されています。


・現バージョンでの注意点

	以下の症状が既知の不具合として報告されています。予めご了承ください。

	・オブジェクトの親子関係が多階層になったときにパラメータの多重な変換を受ける。
	・x形式のモデルデータがobjchild命令による親子関係に対応していない
	・線分モデルがhgviewによる描画エリアの設定に対応していない。

	今後の大幅な機能拡張については、後継プラグインとなるHGIMG4上で実装していく予定です。
	HGIMG3については、引き続き不具合のメンテナンス及び細かい要望の対応を行なっていきたいと
	考えています。


・更新履歴

	2017/05/25 ( Ver3.5β5 )

		OBJ_SORT指定によるソートに失敗することがある不具合を修正

	2014/01/11 ( Ver3.4β3 )

		hgbye命令で終了後に再びhgini命令で初期化した際に正しくウインドウサイズが反映されない不具合を修正


	2013/04/10 ( Ver3.32b )

		fvdirなどfv〜系の命令でベクトル値が正しく認識されない不具合を再度修正
		アプリケーション終了時のクリーンアップ処理でエラーが発生する不具合を修正

	2013/03/15 ( Ver3.32a )

		3.32リリース版でfvdirなどfv〜系の命令で正しくベクトル値が反映されない不具合を修正

	2013/01/29 ( Ver3.32RC1 )

		ogg再生時はDirectSoundソフトウェアバッファをデフォルトで使用するように修正
		ogg再生時のループポイントが初期化されない不具合を修正
		ogg再生時のDirectSoundソフトウェアバッファを使用スイッチを追加
		ogg再生時のストリームバッファサイズ設定を追加
		str2fv命令で不正な文字列が入力された場合の変換方法を修正

	2012/06/14 ( Ver3.31β1 )

		テンプレート定義の含まれていないxファイルの読み込みに対応

	2011/07/07 ( Ver3.3β3 )

		objgetfv命令で配列の情報が正しく設定されないことがある不具合を修正

	2010/04/28 ( Ver3.21a )

		x形式のモデル以外でsetefxによる半透明設定が正しく反映されないことがある不具合を修正
		ドキュメント、リファレンス表記が古かった部分を修正
		HGIMG上位互換のdxfload命令をサポート

	2010/03/17 ( Ver3.21 )

		一部のOSでoggストリームの再生直後にdmmstatで再生時間を取るとフリーズする不具合を修正

	2010/03/15 ( Ver3.21RC3 )

		hgcnvaxisの座標変換でY軸の値が正負逆になる不具合を修正
		自然な音量を設定するサンプル、volsamp.hspを追加
		addline命令による線分が正しく表示されない不具合を修正
		テクスチャ補間方法によってはfprt命令によるフォント描画がぼけて表示される不具合を修正
		setxinfo命令により階層の回転成分を変更する際に移動成分を保存するように修正
		システムリクエストにSYSREQ_FPUPRESERVEオプションを追加

	2010/02/17 ( Ver3.21RC2 )

		直接描画命令(fprt等)のテクスチャフィルター指定をSYSREQ_2DFILTER2に分離

	2010/01/28 ( Ver3.21RC1 )

		外積の計算(fvouter)が間違っていた問題を修正
		hgresetで正しく初期化されないメモリがある不具合を修正
		OBAQ(物理エンジン)プラグインが持つオブジェクトの描画をサポート
		エミッター関連命令(hgemit等)を追加
		groupmod命令を追加
		線分モデル(addline命令)サポートを追加

	2009/10/21 ( Ver3.2a )

		HSP3.1と比較してCPU稼働率が高くなることがある不具合を修正

	2009/07/27 ( Ver3.2RC1 )

		hgreset等でシステムを再初期化した再にタイマー値が取れなくなる不具合を修正
		オブジェクトのモードにOBJ_SORTを追加
		hgcnvaxis命令を追加
		cnvaxis、objsortサンプルを追加

	2009/05/01 ( Ver3.2β3 )

		2D Elements Editor(elm2d)ツール及びサンプルを追加
		オブジェクトのモードにOBJ_FIRSTを追加

	2009/03/11 ( Ver3.2β2 )

		hgprm命令のパラメーター説明を追加。
		delmodel命令を追加。
		マクロ、EPRIM_FANの定義を追加。
		event_pos等のパラメーター変更イベントとevent_jumpによるループを併用すると固まることがあった不具合を修正。

	2008/03/28 ( Ver3.2βtest1 )

		エフェクトモデルについての解説及びサンプルを追加。
		メッシュマップについての解説及びサンプルを追加。
		拡張コリジョンに関するオブジェクトのモードを追加。
		カメラのモードにオブジェクト注視、及び自動追尾を追加。
		meshmap、getvarmap、objwalk、objfloor、getcolvec、getnearobj命令を追加。
		未解説の命令wave_init、wave_apply、wave_setについてのヘルプを追加。

	2007/08/25 ( Ver3.1FIX1 )

		OBJ_LATEを指定した複数のオブジェクト表示において、テクスチャの指定が反映されなくなる不具合を修正。

	2007/07/15 ( Ver3.1RC1 )

		ライセンスに関する記述を修正。

	2007/06/04 ( Ver3.1β10 )

		リアルタイムタイマーの取得、設定を行なうhggettime、hgsettime命令を追加。
		モジュール内でevent_delobj命令を使用するとエラーになる不具合を修正。

	2007/04/06 ( Ver3.1β8 )

		texmes命令で32bitテクスチャ描画時に表示が崩れる不具合を修正。
		[Ctrl]+[Alt]+[Del]等でデバイスが無効になった時、自動的に復帰するように修正。
		一部の環境でfprt命令によるフォント表示が崩れる不具合を修正。
		いくつかのサンプルスクリプトを追加。

	2007/02/07 ( Ver3.1β7 )

		hgsetreq命令でMIPMAP生成の制御ができるオプションを追加。
		texmes命令でメッセージ中の改行コードを認識するように修正。
		文字間、行間、文字アンチエイリアスの設定を行なうtexopt命令を追加。
		ビューポートを設定するためのhgview命令を追加。
		texmes命令でエラーが出ることがあった不具合を修正。
		hgdraw命令のオプションパラメーターを追加。

	2006/11/10 ( Ver3.1β6 )

		エフェクト用モデルの半透明表示に対応。
		イベントリスト操作のためのevent_eprim、event_aim、event_objact命令を追加。
		objact命令で終了時アニメーションIDに-1を指定できるように修正。
		マテリアル数が多い時にトゥーンシェーディング変換に失敗する不具合を修正。
		modelcols、setcolscale命令のパラメーターを追加。
		objaim、hgprm命令を追加。
		DirectSound機能でOggVorbis形式によるストリーム再生に対応。

	2006/07/23 ( Ver3.1β5 )

		DirectSoundの基本機能サポートのための命令(dmm〜)を追加。
		x形式の階層構造モデル表示時にスケールが正しくかからないことがある不具合を修正。
		setxinfo、getxinfo命令に頂点座標、UV座標を指定するオプションを追加。
		sysreq命令にSYSREQ_QUATALGオプションを追加。
		3Dモデルのα合成値オプションにZバッファ無視のモードを追加。
		オブジェクトのプロジェクションモードを変更するobjproj命令を追加。
		イベントリスト操作のためのevent_regobj、event_delobj命令を追加。
		エフェクト用モデル作成と設定のためのaddeprim、seteprim命令を追加。
		x形式によるアニメーション情報の開始フレームを認識するように修正。
		hgsetreq命令にSYSREQ_DXVSYNC、SYSREQ_DEFTIMERオプションを追加。
		setborder命令のオプションを追加。
		regobj命令にイベントID指定のためのパラメーターを追加。
		hgsync命令の精度を上げ負荷率の取得ができるように修正。
		オブジェクトの親子関係を設定するobjchild命令を追加。
		addmesh命令の繰り返しテクスチャ指定(16)が使用できない不具合を修正。

	2006/07/03 ( Ver3.1β4 )

		x形式モデル表示時の回転順序が他のモデルと違っていた不具合を修正。
		x形式モデル表示時の陰影色がアンビエント指定時におかしくなる不具合を修正。
		モデルの回転順序を設定するためのmodelorder命令を追加。
		半球ライティングによる表示オプションをmodelshade命令に追加。

	2006/04/25 ( Ver3.1β3 )

		addplate命令でテクスチャIDを指定した場合に反映されないことがある不具合を修正。
		addbox命令で追加したモデルの光源計算が正しく反映されない不具合を修正。
		x形式モデル表示時に半透明指定がある場合はZバッファを更新しないように修正。
		RGB値で色減算を行なう半透明モード(1024〜)を追加。
		x形式モデルとそれ以外の3Dポリゴンモデル表示順位が正しくない不具合を修正。
		3Dモデルシェーディングモードの設定を行なうmodelshade命令を追加。
		カメラ注視点モードのY座標を反転して認識する不具合を修正。
		カメラ注視点モードの挙動で以前との互換になるスイッチを追加。
		addsplate命令をヘルプに追加。
		addbox、addmesh命令にテクスチャID指定のパラメーターを追加。
		addbox命令で直方体を指定した時に隙間ができる不具合を修正。

	2006/03/14 ( Ver3.1β2 )

		同一モデルを複数表示した場合にアニメーションを独立して再生できない不具合を修正。
		ボーンなしモデルの光源計算がスケールの影響を受ける不具合を修正。
		hgsetreq命令にテクスチャ補間のためのオプションを追加。
		3D描画時は、デフォルトでテクスチャのバイリニア補間を使用するように修正。

	2005/12/22 ( Ver3.1β1 )

		2DオブジェクトのZバッファ更新が無効になるように修正。
		getobjcoli命令を追加。
		getobjmodel命令を追加。
		setcolscale命令を追加。
		modelcols命令を追加。
		objexist命令を追加。
		addbox命令のサイズパラメーターが認識されない不具合を修正。
		イベントによるパラメーター変更に相対値を使用可能に修正。

	2005/11/28 ( Ver3.1β1 )

		settoonedgeの説明が間違っていたのを修正。
		ボーンなしモデルのトゥーンシェーディング時にマテリアルが反映されない不具合を修正。
	2005/08/30 ( Ver3.0a )

		HSP3.0aライブラリでビルド。
		xファイルによるアニメーション最大数を設定できるように修正。
		xファイル読み込み時の法線再計算をON/OFFできるように修正。
		xファイル読み込み時にマテリアルがずれることがある不具合を修正。
		xファイルによるモデル描画で加減算合成ができない不具合を修正。
		半透明オブジェクト描画用のOBJ_LATEフラグを追加。
		event_uv命令がplateモデルに対して動作しない不具合を修正。
		clstex命令で指定したテクスチャが背景に設定されるように修正。

	2005/08/01 ( Ver3.0 )

		HSP3.0ライブラリでビルド。

	2005/07/13 ( Ver3.0β8 )

		HSP3.0β12ライブラリでビルド。

	2005/06/23 ( Ver3.0β7 )

		回転アニメーションの補間方法を球面線形に修正。
		ボーンのないモデルの光源計算が間違っていたのを修正。
		getxinfo命令のパラメーター仕様を一部変更。
		getxinfo、setxinfo命令によるマテリアル情報の読み書きに対応。

	2005/06/22 ( Ver3.0β6 )

		ライト色、アンビエント色の反映がおかしかった部分を修正。
		１本のボーンに100%依存するメッシュの表示に対応。
		カメラ画角(FOV)、表示範囲(near,far)パラメーターが反映するように修正。
		ウインドゥサイズに合わせてカメラアスペクト比を補正するように修正。
		hggetreq命令でDirectXのCOMポインタを取得できるように修正。
		getxinfo、setxinfo命令を追加。

	2005/06/15 ( Ver3.0β5 )

		HSP3.0β10ライブラリでビルド。
		ライト色、アンビエント色が正しく反映されていなかったのを修正。
		アニメーション切り替え時にスピードをデフォルトに戻すように修正。
		reglight、objlight命令を追加。

	2005/05/27 ( Ver3.0β4 )

		HSP3.0β8ライブラリでビルド。
		hgline、hgcapture命令を追加。
		ボーンを含む一部のモデルが正しく表示されない不具合を修正。
		addspr、addplate命令にテクスチャID指定のパラメーターを追加。
		event_set系の命令でパラメーター省略時に正しく動作しない不具合を修正。

	2005/04/12 ( Ver3.0β3 )

		HSP3.0β7ライブラリでビルド。デバッグウインドゥに対応。
		modelspeed命令を追加。

	2005/03/23 ( Ver3.0β2 )

		xファイル読み込み時の法線再計算を行なわないように修正。
		fvouter,fvsub,fvdiv命令の計算順序が逆になっていた不具合を修正。
		複数アニメーション登録のためのaddxanim命令を追加。
		アニメーション設定のためのobjact,objspeed,getanim命令を追加。

	2005/02/25 ( Ver3.0β1 )

		テスト版として初出。


・命令一覧(メイン)

	hgini yofs,ysize			DLLの初期化
	hgreset							シーン情報の初期化
	hgdraw mode					描画の実行
	hgbye							DLLの開放
	hgsync val						時間待ちを行なう
	hgsetreq type,val				システムリクエスト設定
	hggetreq val,type				システムリクエスト取得

	setborder sx,sy,sz,option				オブジェクト有効範囲設定
	clscolor color					背景色設定
	clstex id						背景テクスチャ設定
	setfont cx,cy,px,sw				オリジナルフォント定義
	fprt "mes",x,y					定義フォント文字列表示

	cammode mode					カメラモードの設定

	objact ObjID,anim,mode				指定アニメーションを開始

	setuv tx0,ty0,tx1,ty1			登録テクスチャUV座標を指定
	setsizef sx,sy					登録モデルの幅、高さを指定
	addbox var,sx,sy,texid				箱(BOX)モデルを作成
	addplate var,mode,sx,sy,texid			板(PLATE)モデルを作成
	addspr var,mode,x1,y1,x2,y2,texid		2Dスプライトモデルを作成
	addxfile model,"filename"		モデルファイル読み込み

	regobj var,ModelID,mode,EventID		オブジェクトの登録
	delobj ObjID					オブジェクトの削除
	setobjmodel ObjID, ModelID		オブジェクトのモデル設定
	setobjmode id,mode,sw			オブジェクトのモード設定
	setcoli id,mygroup,enegroup		オブジェクトのコリジョン設定
	getcoli val,id,distance			オブジェクトのコリジョン判定
	findobj exmode,group			オブジェクト検索
	nextobj val						次のオブジェクト検索

	clsblur val						ブラー設定
	setcolor r,g,b					単色ポリゴン作成設定
	falpha val						フォント文字α値を設定


・命令一覧(補助)

	selmoc id, mocofs				MOC情報を設定
	selpos id						移動座標をMOC情報に設定
	selang id						回転角度をMOC情報に設定
	selscale id						スケールをMOC情報に設定
	seldir id						移動量をMOC情報に設定

	selcam ofs						カメラをMOC情報に設定
	selcpos							カメラ座標をMOC情報に設定
	selcang							カメラ角度をMOC情報に設定
	selcint							カメラ注視点をMOC情報に設定

	sellight id,ofs					光源をMOC情報に設定
	sellpos	id						光源座標をMOC情報に設定
	sellang	id						光源角度をMOC情報に設定
	sellcolor id					光源色をMOC情報に設定

	objset1 ofs,x					MOC情報を設定
	objadd1 ofs,x					MOC情報を加算
	objsetf1 ofs,x					MOC情報を設定
	objaddf1 ofs,x					MOC情報を加算
	objset1r ofs,x					MOC情報を設定

	objset2 ofs,x,y					MOC情報を設定
	objadd2 ofs,x,y					MOC情報を加算
	objsetf2 ofs,x,y				MOC情報を設定
	objaddf2 ofs,x,y				MOC情報を加算
	objset2r ofs,x,y				MOC情報を設定

	objset3 x,y,z					MOC情報を設定
	objadd3 x,y,z					MOC情報を加算
	objsetf3 x,y,z					MOC情報を設定
	objaddf3 x,y,z					MOC情報を加算
	objset3r x,y,z					MOC情報を設定

	objgetfv fv						MOC情報を取得
	objsetfv fv						MOC情報を設定
	objaddfv fv						MOC情報を加算
	objgetv v						MOC情報を整数値で取得
	objsetv v						MOC情報を整数値で設定
	objgetstr sval					MOC情報を文字列で取得

	fvset fv,x,y,z					ベクトル設定
	fvseti fv,x,y,z					整数値からベクトル設定
	fvadd fv,x,y,z					ベクトル加算
	fvsub fv,x,y,z					ベクトル減算
	fvmul fv,x,y,z					ベクトル乗算
	fvdiv fv,x,y,z					ベクトル除算
	fvdir fv,x,y,z					ベクトル回転
	fvmin fv,x,y,z					ベクトル最大値
	fvmax fv,x,y,z					ベクトル最小値
	fvouter fv,x,y,z				ベクトル外積
	fvinner fv,x,y,z				ベクトル内積
	fvface fv,x,y,z					座標から角度を得る
	fvunit fv						ベクトル正規化
	fsin fval,rot					サインを求める
	fcos fval,rot					コサインを求める
	fsqr fval,prm					平方根を求める
	froti fval,prm					整数値角度を小数値に変換

	fv2str fv						ベクトルを文字列に変換
	str2fv fv,"x,y,z"				文字列をベクトルに変換
	str2f fval,"val"				文字列を小数値に変換
	f2str val,fval					小数値を文字列に変換

	settex x,y,sw,mode				テクスチャを登録

	modelscale id,x,y,z				モデルの拡大縮小
	modelshade id,mode				モデルシェーディングモードの設定

	dxfload "file"					DXF形式ファイルを読み込み


・動作の概要

	HGIMG3は、すべてのマシンで同等の表示、最適化された速度を再現できるように
	開発されています。3Dアクセラレーターを搭載しない機種(ノート型やオンボード
	ビデオチップ搭載機種など)、であっても著しくパフォーマンスが落ちることなく
	動作させることができます。また、初期化を手軽に行なえるとともにDirectX
	バージョンの不一致やドライバの相性などによる不具合を最小限に抑えることを
	目指しています。

	HGIMG3では、「モデル」と「オブジェクト」という単位で描画の管理を行なって
	います。HSPの命令の多くは、準備の必要もなく目的の処理を行なっていましたが、
	HGIMG3では、最初の準備段階として使うものを「登録」しておき、後でまとめて
	全部を描画するスタイルを取っています。これは直感的ではない反面、処理の効率化
	と高速化を図ることができます。HGIMG3には、100種類以上の命令があり最初は
	その複雑さに戸惑うかもしれませんが、最低限使うものはわずかですので、少しづつ
	使って覚えていってください。

	何らかの絵を出す場合には、最初に「モデル」を登録する必要があります。
	「モデル」は、

		・2Dスプライト
		・3Dスプライト(板)
		・立方体
		・3Dモデル

	のような種類があり、それぞれの種類に応じて色々な設定項目があります。
	たとえば、2Dの絵を画面に表示したい場合は、種類が「2Dスプライト」の「モデル」
	を最初に登録しなければなりません。
	「2Dスプライト」は、表示に使う絵(テクスチャ)やアニメーションの設定などが
	あり、必要な項目を設定すればOKです。

	「モデル」を登録しただけでは画面には何も表示されません。
	「モデル」は、画面に表示するための材料となります。画面に表示される可能性が
	あるものをあらかじめ材料としてストックしておくものと考えて下さい。

	「モデル」に続いて、「オブジェクト」を登録します。
	「オブジェクト」は「どの場所にどのモデルを出すか」という情報を持った器の
	ようなものです。「オブジェクト」が指す「モデル」を画面に表示します。
	「オブジェクト」は単なる器なので、同じ物体を２つ画面に出す場合には、
	「モデル」を1つ登録して、そのモデルを持った「オブジェクト」を２つ登録すれば
	いいことになります。「モデル」は、その形や色自体の情報を持っておき、
	「オブジェクト」は、「モデル」を画面上に出す場所や動きの設定などを持っている
	と考えておいてください。

	これらの概念をもとに、2D、3D画像をコントロールするための命令が多数用意されて
	います。
	HGIMG3は内部では、すべて32bit浮動小数によりパラメータを管理、演算されて
	います。命令のパラメーターで小数が必要な部分では、HSP3.0の実数指定および
	実数型変数に完全に対応しています。
	たとえば、

			objadd3 1.0, 1.5, 2.0

	のように実数値による指定が可能です。また、

			objadd3 1, 1, 2

	のように整数値でも受け付けます。

	大量の画像や、3Dデータを使用したソフトで問題となるのは描画にかかる負荷、
	つまり絵を描くのに時間がかかってしまう点です。



	HGIMG3では、単位時間あたりの移動量から動きの計算を行なうタイムスケール
	モードを搭載することで、高速なマシンではより高いフレームレートで
	動作させることで、マシンスペックによる画面上の動作速度の違いを吸収
	させることができます。


・初期化と描画の方法

	HGIMG3では、初期化を以下の手順に従って行なって下さい。

	;------------------------------------------------------------------
	screen 0,320,240,0
	hgini						; hgimgの初期化
	;------------------------------------------------------------------

	hgini命令は、プラグインの全初期化を行なう命令です。
	hgini命令が実行された時点でアクティブなウインドゥのサイズと、
	色モードをもとに初期化を行ないます。
	上の例では、320x240ドット、フルカラーモードで描画を行なうことに
	なります。

	初期化を連続して行なうことはできません。
	再初期化する場合は、hgbye命令ですべての終了処理を行なった後に実行
	するようにしてください。

	また、hgbye命令ですべての終了処理が行なわれます。
	hgbye命令自体は、自動クリーンアップ命令でHSPの終了時に自動的に
	呼び出されるため、通常は記述する必要はありません。

	初期化が終わったら、いつでも登録されているオブジェクトを表示可能な
	状態になります。
	HGIMG3では、描画を以下のように行ないます。

	;------------------------------------------------------------------
	*main
		;	描画メイン
		;
		hgdraw				; 描画処理
		hgsync 10			; 時間待ち
		goto *main
	;------------------------------------------------------------------

	hgdraw命令で、HGIMG3が受け持つすべての描画を行ないます。
	この時、描画先のウインドゥをgsel命令などでアクティブにしておくのを
	忘れないでください。
	その後、hgsync命令で時間待ち(ウェイト)をします。「hgsync 10」の場合は、
	10msだけ待ち時間を入れます。
	この２つの命令を必ず入れれば全描画と待ち時間の処理は完結します。
	HSPのwaitやawait命令を入れる必要はありません。


・モデル設定命令

	モデルの登録をするためには、種類に応じて命令が異なります。
	主な登録の方法は以下の通りです。

	・2Dスプライト

		setuv tx0,ty0,tx1,ty1		;UV座標の設定
		addspr val, mode			;2Dスプライトモデルを作成

		テクスチャ座標の左上(tx0,ty0)と右下(tx1,ty1)の大きさに
		応じたサイズの2Dスプライトモデルを作成します。
		回転、拡大縮小、合成などを行なうことができます。
		変数valにモデルIDが代入されます。
		これに続いてtexload命令で読み込まれたテクスチャ(画像)を使用します。
		addspr命令のmode値が0の場合は透明色抜き処理を行ないません。
		mode値が1の場合は指定された色を透明色として扱って描画します。

	・2DBGマップ

		setbg sx,sy,cx,cy					;マップサイズ、チップサイズ設定
		addbg val, winsizex, winsizey,sw	;2DBGマップモデルを作成

		マップのサイズが(sx,sy)、チップサイズを(cx,cy)とするBGマップ表示
		モデルを作成します。
		変数valにモデルIDが代入されます。
		これに続いてtexload命令で読み込まれたテクスチャ(画像)を使用します。

	・単色3Dスプライト(板)

		setsizef sx,sy				;板の大きさ設定
		setcolor 0,255,0			;色の設定
		addplate val, mode			;板(PLATE)モデルを作成

		縦横サイズが(sx,sy)の四角ポリゴン(板)のモデルを作成します。
		色は、緑(R=0,G=255,B=0)となります。
		変数valにモデルIDが代入されます。
		mode値が2の場合は光源計算を行ないます。

	・3Dスプライト(板)

		setsizef sx,sy				;板の大きさ設定
		setuv tx0,ty0,tx1,ty1		;UV座標の設定
		addplate val, mode			;板(PLATE)モデルを作成

		テクスチャ座標が左上(tx0,ty0)と右下(tx1,ty1)のもので、
		縦横サイズが(sx,sy)の四角ポリゴン(板)のモデルを作成します。
		変数valにモデルIDが代入されます。
		これに続いてtexload命令で読み込まれたテクスチャ(画像)を使用します。
		addplate命令のmode値が0の場合は透明色抜き処理を行ないません。
		mode値が1の場合は指定された色を透明色として扱って描画します。

	・単色の箱(立方体)

		setsizef sx,sy				;箱の大きさ設定
		setcolor 255,0,0			;色の設定
		addbox val,2				;箱(BOX)モデルを作成

		サイズが(sx,sy)の箱(立方体)モデルを作成します。
		色は赤(R=255,G=0,B=0)で、光源計算を行ないます。
		変数valにモデルIDが代入されます。

	・テクスチャ使用の箱(立方体)

		setsizef sx,sy				;箱の大きさ設定
		setuv tx0,ty0,tx1,ty1		;UV座標の設定
		addbox val					;箱(BOX)モデルを作成

		サイズが(sx,sy)の箱(立方体)モデルを作成します。
		テクスチャ座標は左上(tx0,ty0)と右下(tx1,ty1)が１つの面となり、
		さらに(tx0,(ty1-ty0)+1)と、(tx0,((ty1-ty0)+1)*2)からの3つの面を
		テクスチャとして持つ箱モデルが作られます。
		変数valにモデルIDが代入されます。
		これに続いてtexload命令で読み込まれたテクスチャ(画像)を使用します。

	・3Dモデル

		addxfile model,"filename"		;モデルファイル読み込み

		"filename"で指定されたポリゴンモデルファイル(拡張子x)を読み込み
		モデルとして登録します。また、テクスチャも同時に読み込まれます。
		終了すると指定された変数名にモデルIDが代入されます。

	・線分

		addline model,-1,$ffffffff		;線(LINE)モデルを作成

		白色の線を引くためのモデルを作成します。
		変数modelにモデルIDが代入されます。
		線を引くベクトルは、workグループに設定されたものが使用されます。

	モデル追加のための命令は、これ以外にもadddxf等の補助命令が存在します。
	詳しくはリファレンスを参照してください。


・オブジェクト設定命令

	オブジェクトを登録する場合は、

		regobj 変数名, モデルID, モード

	の命令を使用します。
	regobjでは、すでに登録されているモデルIDと、モードを指定する必要が
	あります。
	モードは以下の中から選択します。

		ラベル             |        内容
		--------------------------------------------------------------
		OBJ_HIDE             非表示(画面から消す)
		OBJ_TREE             木属性(Y軸のみ正面を向く)
		OBJ_XFRONT           正面属性(常に画面に正面を向く)
		OBJ_MOVE             XYZ移動量を有効にする
		OBJ_FLIP             ボーダー領域で反転する
		OBJ_BORDER           ボーダー領域を有効にする
		OBJ_LATE             常に後から描かれる(半透明オブジェクト用)
		OBJ_FIRST            常に最初に描かれる
		OBJ_SORT             自動的に奥から描かれる(3Dオブジェクト用)
		OBJ_LOOKAT           特定オブジェクトの方向を常に向く
		OBJ_LAND             Y座標を常に一定に保つ
		OBJ_GROUND           地面として認識される
		OBJ_STAND            地面の上に配置する
		OBJ_GRAVITY          重力計算を有効にする
		OBJ_STATIC           障害物として認識される
		OBJ_BOUND            地面で反発する(メッシュマップコリジョン用)
		OBJ_ALIEN            ターゲットに向ける(メッシュマップコリジョン用)
		OBJ_WALKCLIP         移動の制限を受ける(メッシュマップコリジョン用)
		OBJ_EMITTER          エミッター発生オブジェクトになる

	複数の項目を同時に選択する場合は、「OBJ_LATE|OBJ_MOVE」のように
	「|」で区切って指定してください。何も指定しない場合は、0にするか
	省略して構いません。
	オブジェクトのモードは、あらかじめデフォルトのモードがモデルの種類に応じて
	設定されているので、通常は特に設定する必要はありません。
	また、setmode命令でモデルにモードを指定した場合は、そのモードが
	オブジェクトにも継承されます。

	正常にオブジェクトが登録されると変数にオブジェクトIDが
	返されます。オブジェクトIDは、その後にオブジェクトのパラメータや
	設定を変更する場合に必要になる番号です。

	オブジェクトの設定を後から変更する命令は以下の通りです。

		setobjm ObjID, ModelID			オブジェクトのモデル設定
		setobjmode id,mode,sw			オブジェクトのモード設定
		setcoli id,mygroup,enegroup		オブジェクトのコリジョン設定

	オブジェクトの設定は、MOC設定命令でも行なうことができます。
	詳しくは、MOC設定命令についてを参照してください。
	以下は2Dスプライトのモデルを登録して、さらにそれをオブジェクトとして
	登録するスクリプトの例です。

			例:
				;	スプライトの登録
				;
				setuv 0,0,79,79				; UV座標指定
				addspr pchr					; モデルの登録
				texload "rock2.bmp"			; テクスチャの登録
				regobj mychr,pchr,OBJ_2D	; オブジェクト登録


・オブジェクトパラメーター設定命令について

	HGIMG3では、「オブジェクト」１つ１つが独立したパラメーターを持っており、
	その内容に従って表示および動作が決定されます。
	これら、「オブジェクトパラメーター」は表示位置、回転角度、サイズ、移動量
	など複数の情報を持っており、すべて浮動小数で記憶しています。
	すべてのパラメータは、任意の値に変更、取得が可能なほか、イベントリストを
	使用することで、指定フレーム後に任意の値になるように値を増減させるなど
	様々なコントロールが可能になっています。

	HGIMG3の「オブジェクト」は、以下のようなパラメータを持っています。

	グループ    offset0      offset1     offset2      offset3
	--------------------------------------------------------------
	  pos       [X座標]      [Y座標]     [Z座標]      [未使用]
	  ang       [X回転角]    [Y回転角]   [Z回転角]    [未使用]
	  scale     [X倍率]      [Y倍率]     [Z倍率]      [未使用]
	  dir       [X移動量]    [Y移動量]   [Z移動量]    [未使用]
	  efx       [α合成値]   [未使用]    [未使用]     [未使用]
	  work      [workX]      [workY]     [workZ]      [未使用]

	パラメーターは、４つの値を１つのグループとして扱っています。
	たとえば、「グループpos」は、表示するX,Y,Z座標を保存しています。
	この「グループpos」を変更すれば、画面上の表示位置も変更されます。

	実際にパラメーターを設定する場合には、以下の命令を使います。

		setpos id,x,y,z
		setang id,x,y,z
		setscale id,x,y,z
		setdir id,x,y,z
		setefx id,x,y,z
		setwork id,x,y,z

	それぞれのグループに対して、(x,y,z)の３つのパラメーターを設定
	することができます。idには、個々のオブジェクトを識別するための
	オブジェクトIDを指定します。オブジェクトIDは、regobj命令によって
	オブジェクトが登録された際に返される番号です。
	x,y,zのパラメーターには、整数かまたは実数を指定することができます。
	値の指定を省略した場合には、値0として処理されます。

	オブジェクトの各グループは、以下のような意味を持っています。

		 グループ pos: (初期値:0,0,0)
			オブジェクトのX,Y,Z座標を指定します。
			2Dオブジェクトの場合は、(X,Y)が座標に使用され、
			Zは優先度(0.0〜1.0)として扱われます。
			また、2Dオブジェクトの座標は画面の中心が(0,0)となります。

		 グループ ang: (初期値:0,0,0)
			オブジェクトの向いているX,Y,Z角度を指定します。
			角度の単位はラジアン(1周でπ*2)になります。
			オブジェクトの回転は、常にZ->Y->Xの順番に行なわれます。

		 グループ scale: (初期値:1,1,1)
			オブジェクトの倍率(X,Y,Z軸)を指定します。

		 グループ dir: (初期値:0,0,0)
			オブジェクトのX,Y,Z方向に対する移動量を指定します。
			OBJ_MOVEのモードが設定されている時に参照されます。

		 グループ efx: (初期値:256,0,0,0)
			オブジェクトの特殊効果を設定します。
			4つの値を格納していますが、
			オフセット0 : [α合成値]
			オフセット1 : [EFX1]
			オフセット2 : [EFX2]
			オフセット3 : [EFX3]
			となっています。
			(*現バージョンではグループEはα合成値のみサポートされています)

			α合成値は、背景とオブジェクトを合成する度合いを指定します。

			α合成値 = 0〜255    : 背景とα合成(blend)を行なう
			α合成値 = 256〜511  : 合成を行なわない(通常時)
			α合成値 = 512〜767  : 背景と色加算(modulate)を行なう
			α合成値 = 768〜1023 : 背景とα値減算(substract)を行なう
			α合成値 = 1024〜1279 : 背景と色減算(substract2)を行なう
			α合成値 = 1280〜1535 : 合成を行なわない(Z無視)

			合成を行なう場合には、α合成値の値が大きいほど、高い%で合成が
			行なわれます。α合成は、シェーディング、2D、3Dの区別なく処理
			されます。

			α値減算(substract)は、背景のRGB値に対してα値を減算します。
			色減算(substract2)は、背景のRGB値に対して描画するテクスチャの
			RGBを現在します。この時、α値は反映しません。
			(HSP標準の色減算と動作が一部異なりますので注意してください。)
			合成を行なわない(Z無視)のモードは、3Dモデルにのみ有効で、
			Zバッファの更新及び深度テストを行ないません。

		 グループ work: (初期値:0,0,0,0)
			イベントリストで使用される汎用的なパラメーターです。


	「オブジェクト」の中には、特殊な動作を行なうものがあり、これらは
	パラメーターを別な用途として使用しているものがあります。

	「カメラオブジェクト」

	画面に表示するための視点を示すものがカメラオブジェクトになります。
	HGOBJ_CAMERAが、カメラオブジェクトのオブジェクトIDとなります。

		例:
			; カメラの座標を(0,0,20)に設定する
			setpos HGOBJ_CAMERA,0,0,20

	カメラオブジェクトの時のみ、グループのパラメーターは以下の意味を
	持つことになります。

	グループ    offset0      offset1     offset2      offset3
	--------------------------------------------------------------
	  pos       [X座標]      [Y座標]     [Z座標]      [未使用]
	  ang       [X回転角]    [Y回転角]   [Z回転角]    [未使用]
	  scale     [X倍率]      [Y倍率]     [Z倍率]      [未使用]
	  dir       [X注視座標]  [Y注視座標] [Z注視座標]  [未使用]
	  efx       [FOV]        [NearZ値]   [FarZ値]     [未使用]

	dirは注視点(カメラが注目する座標)を示します。
	(ただし、cammode命令で注視点モード設定中のみ参照されます。)
	efxの各パラメーターは、カメラの詳細な設定を示します。
	FOVは、画角(パースのかかりぐあいを調整する値)でラジアン単位の
	指定を行ないます。デフォルトで、45度(π/4)が指定されています。
	NearZとFarZは、表示を行なうZ軸の範囲(Zクリッピング範囲)を指定
	を行ないます。NearZは手前(どこまで近い物体を描画するか)、
	FarZは奥(どこまで遠い物体を描画するか)を示します。
	デフォルトで、NearZは0.5、FarZは768.0が設定されています。
	カメラのefxグループパラメーターは、HGIMG2.61のものと互換性が
	ありませんので注意してください。

	「ライトオブジェクト」

	3D空間上のモデルに光をあてるライトを示すものとして、ライトオブジェクト
	が存在しています。
	HGOBJ_LIGHTが、標準のライトオブジェクトのオブジェクトIDとなります。
	ライトオブジェクトは、reglight命令によって任意に追加することが可能です。

		例:
			; ライトの向きを(0,0.4,-0.1)に設定する
			setang HGOBJ_LIGHT,0,0.4,-0.1

	ライトオブジェクトの時のみ、グループのパラメーターは以下の意味を
	持つことになります。

	グループ    offset0      offset1     offset2      offset3
	--------------------------------------------------------------
	  pos       [X座標]      [Y座標]     [Z座標]      [未使用]
	  ang       [X回転角]    [Y回転角]   [Z回転角]    [未使用]
	  scale     [カラーR]    [カラーG]   [カラーB]    [未使用]
	  dir       [ambientR]   [ambientG]  [ambientB]   [未使用]
	  efx       [range]      [falloff]   [theta]      [phi]

	グループscaleがライトの色、グループdirがアンビエント色のパラメーター
	として使用されます。それぞれのパラメーターは、R,G,Bの要素を0.0〜255.0で
	表わした値となります。
	デフォルトで、ライト色は(255,255,255)、アンビエント色は(0,0,0)が
	設定されています。光源の計算は、シェーディングモードによって
	異なります。詳しくは、modelshade命令のリファレンスか、
	「シェーディングモードの設定について」を参照してください。
	グループefxは、ポイントライト、スポットライトのための拡張設定で、
	現バージョンでは無視されます。
	(ライトのdir,scaleグループパラメーターは、HGIMG2.61のものと互換性が
	ありませんので注意してください。)

	現在のバージョンでは、X形式のモデルに対しシェーディングモード１では
	ライトのscale(カラー)パラメータは反映されない仕様となっていますので
	ご了承ください。

	以下は、オブジェクトパラメーターの値を取得するための命令です。

		getpos id,x,y,z
		getang id,x,y,z
		getscale id,x,y,z
		getdir id,x,y,z
		getefx id,x,y,z
		getwork id,x,y,z

	これらの命令では、x,y,zに読み出し先の変数名を指定します。

		例:
			; カメラの座標を変数a,b,cに読み出す
			getpos HGOBJ_CAMERA,a,b,c

	上の例では、変数aにX座標が、変数bにY座標が、変数cにZ座標が
	それぞれ実数型で代入されます。
	整数値でパラメーターを取得する場合は、以下の命令を使用します。

		getposi id,x,y,z
		getangi id,x,y,z
		getscalei id,x,y,z
		getdiri id,x,y,z
		getefxi id,x,y,z
		getworki id,x,y,z

	最後に「i」が付加された命令は、整数値で変数に代入されます。
	座標を整数のみで扱う場合や、高速化を行ないたい場合に使用する
	ことができます。

	また、パラメーターに対して直接加算を行なうための命令が用意
	されています。

		addpos id,x,y,z
		addang id,x,y,z
		addscale id,x,y,z
		adddir id,x,y,z
		addefx id,x,y,z
		addwork id,x,y,z

	それぞれのグループに対して、(x,y,z)の３つのパラメーターを加算
	します。

		例:
			; オブジェクトID5の物体をX+10,Y-20移動させます
			addpos 5, 10, -20, 0

	これらの命令は、パラメーターの値を直接加算、減算するような
	場合に便利です。

	パラメーターの中で、「グループang」は角度を格納するためのもので、
	通常ラジアン単位によって指定します。
	しかし、ラジアンは直感的に利用することが難しい場合があるため、
	「グループang」のみ整数値で操作するための命令が用意されています。

		setangr id,x,y,z
		addangr id,x,y,z
		getangr id,x,y,z

	これらの命令では、回転情報を0〜255までを１周として扱います。
	つまり、0が0度、64が90度、128が180度…となります。
	これは、整数を使った高速で手軽な角度の設定方法です。
	256段階の角度よりも細かい単位での指定を行なう場合には、
	通常のラジアン単位をお使い下さい。

	オブジェクトパラメーターを設定する方法として、もう１つ別な
	やり方が用意されています。これは、「MOC設定命令」と呼ばれる
	命令セットを使用する方法です。「MOC設定命令」は、HGIMG2で使用
	されていた設定方法で、より細かくパラメーターの取得や演算を
	行なうことが可能です。

	「MOC設定命令」についての詳細は、「MOC設定命令について」の項を
	参照してください。


・直接描画命令について

	HGIMG3では、オブジェクトを登録してまとめて描画を行なう従来までの
	方法とともに、直接命令実行時に描画を発行させるための直接描画命令が
	用意されています。
	直接描画命令は、登録されているオブジェクトやモデルとか関係なく
	画面上に任意の矩形やテクスチャを描画することができます。

	直接描画命令は、必ずhgdrawとhgsyncの間に描画を行なう必要がありますので
	注意してください。

		例:
			;	描画メイン
			;
		*main
			hgdraw				; 描画処理
			color 255,0,0
			hgrect 320,240,0,100,100
			hgsync 10			; 時間待ち
			goto *main

	以下が直接描画命令になっています。
	hgrect、hgrotate命令は、それぞれ標準命令のgrect、grotate命令と同じ動作を
	HGIMG3の画面に対して行なう命令セットになっていますので、標準命令から移植
	するような場面にも有効です。

	hgrect p1,p2,p3,p4,p5,p6		矩形の直接描画

	p1=0〜(0)  : 矩形の中心X座標
	p2=0〜(0)  : 矩形の中心Y座標
	p3=0〜(0.0): 回転角度(単位はラジアン)
	p4=0〜(?)  : Xサイズ
	p5=0〜(?)  : Yサイズ

	(p1,p2)で指定した座標を中心として、(p4,p5)で指定したサイズの矩形(長方形)を
	現在設定されている色で描画します。
	p3で回転角度を実数で指定することができます。
	角度の単位は、ラジアン(0から始まって、2πで一周)となります。
	grect命令は、gmodeで設定されたコピーモードの指定が反映されます。

	gmodeが0,1の場合は、通常の塗りつぶし。
	gmodeが3の場合は、指定されたレートで半透明になります。
	gmodeが5,6の場合は、それぞれ色加算、色減算処理となります。
	また、(p4,p5)のサイズ指定を省略した場合には、gmode命令で設定されている
	コピーサイズが使用されます。


	hgrotate p1,p2,p3,p4,p5,p6		矩形画像の直接描画

	p1=0〜(0)  : テクスチャID
	p2=0〜(0)  : コピー元の左上X座標
	p3=0〜(0)  : コピー元の左上Y座標
	p4=0〜(0.0): 回転角度(単位はラジアン)
	p5=0〜(?)  : Xサイズ
	p6=0〜(?)  : Yサイズ

	hgrotate命令は、指定された矩形範囲に回転を含めたテクスチャ描画処理を
	行ないます。p1で、コピー元のテクスチャIDを指定、(p2,p3)でコピーされる
	元の画像にあたる座標を指定します。(gcopy命令と同様です)
	コピー先は、現在の描画先に指定されているウインドゥIDで、
	pos命令で設定された場所を中心とした座標にコピーを行ないます。
	その際に、p3で回転角度を実数で指定することができます。
	角度の単位は、ラジアン(0から始まって、2πで一周)となります。
	(p5,p6)で、コピーされた後のX,Yサイズを指定します。
	また、コピー元のX,Yサイズはgmode命令で設定されたデフォルトの
	コピーサイズが使用されます。
	つまり、gmode命令で指定されたサイズよりも大きなサイズを(p5,p6)
	で指定した場合には、拡大されることになります。
	(p5,p6)を省略した場合には、コピー元と同じサイズ、つまり等倍で
	コピーが行なわれます。

	hgrotate命令は、gmodeで設定されたコピーモードの指定が反映されます。
	(詳しくはgmode命令のリファレンスを参照してください)



・イベントリストについて

	イベントリストは、決まった流れの処理(イベント)をあらかじめ用意
	しておいて、それを個々のオブジェクトに対して適用させるための
	機能です。

	イベントリストを使用するためには、大きく分けて

		「イベントリストの作成」と「イベントリストの適用」

	という２つの段階があります。
	まず、「イベントリストの作成」であらかじめ特定の処理を決めて
	おきます。たとえば、「○○の座標に移動する」とか「X座標を1足す」
	など各種パラメーターに対して細かい動作を決めることができます。
	こうした処理をイベントと呼び、それを複数まとめたものをイベントリスト
	と呼ぶようにしています。

	イベントリストを作成するには、以下のように記述します。

		例:
			newevent ev1	; 新しいイベントIDを取得
			event_setpos ev1, 10,20,30

	上の例では、座標パラメーターとして(10,20,30)を設定するための
	イベントを作成して、そのIDを変数ev1に代入しています。
	新しくイベントを作成する場合には、必ずnewevent命令でイベントIDを
	取得しておきます。次に、event_setpos等のイベント登録用の命令で、
	指定されたイベントIDにイベントを追加していきます。
	一度取得されたイベントIDは、シーンのリセット(hgreset命令)が
	行なわれるか、またはdelevent命令によってイベントリストが削除
	されるまでは保持されます。

	こうしてできたイベントは、好きな時にオブジェクトに対して適用
	させることができます。

		例:
			newevent ev1	; 新しいイベントIDを取得
			event_setpos ev1, 10,20,30
			; objidのオブジェクトにev1のイベントを適用
			setevent objid, ev1

	この例では、objidが示すオブジェクトに対してev1のイベントリスト、
	つまり(10,20,30)を座標として設定するという処理を適用します。
	このように、イベントではパラメーターに対しての動作をまとめて
	登録することができ、それを特定のオブジェクトに反映させる働きを
	持ちます。
	event_setposでは、座標設定のイベントを登録しますが、それ以外の
	パラメーターを設定するための命令も用意されています。

		event_setpos eventid, x, y, z
		event_setang eventid, x, y, z
		event_setangr eventid, x, y, z
		event_setscale eventid, x, y, z
		event_setdir eventid, x, y, z
		event_setefx eventid, x, y, z
		event_setwork eventid, x, y, z

	それぞれのグループに設定するX,Y,Z値を実数または整数値で指定
	することができます。
	また、

		event_setpos eventid, x1, y1, z1, x2, y2, z2

	のように、X,Y,Zの範囲を指定することにより、乱数で指定された
	範囲内の値を自動的に生成させることもできます。

		例:
			newevent ev1	; 新しいイベントIDを取得
			event_setpos ev1, 10,20,30,30,20,50

	上の例では、XYZ=(10〜30,20,30〜50)までの値が設定されます。
	設定だけでなく、パラメーター値に対して加算を行なうイベントも
	登録することができます。

		event_addpos eventid, x, y, z
		event_addang eventid, x, y, z
		event_addangr eventid, x, y, z
		event_addscale eventid, x, y, z
		event_adddir eventid, x, y, z
		event_addefx eventid, x, y, z
		event_addwork eventid, x, y, z

	これらの命令は、特定グループのパラメーターに対して(X,Y,Z)の
	値を加算します。(マイナス値を指定することで減算になります。)

	イベントでは、パラメーター設定の他にも時間経過に応じた処理を
	追加することができます。

		例:
			newevent ev1	; 新しいイベントIDを取得
			event_pos ev1, 20, 0,10,20

	上の例では、２０フレーム後に(0,10,20)の座標に移動するイベントが
	登録されます。このイベントが適用されたオブジェクトは、自動的に
	２０フレームの間指定された座標まで移動を行ないます。

	単純な待ち時間を登録するためのevent_wait命令も用意されています。
	event_waitイベントでは、指定されたフレーム数が経過するまで次の
	イベント処理を待ちます。

	複数のevent_posイベントを登録することにより、移動の経路を
	細かく指定しておくことが可能です。

		例:
			newevent ev1	; 新しいイベントIDを取得
			event_pos ev1, 20, 10,0,0
			event_wait ev1, 20
			event_pos ev1, 20, 10,10,0
			event_wait ev1, 20
			event_pos ev1, 20, 0,10,0
			event_wait ev1, 20
			event_pos ev1, 20, 0,0,0
			event_wait ev1, 20

	上の例では、(10,0,0)→(10,10,0)→(0,10,0)→(0,0,0)の順番に
	移動を行ないます。
	event_posなど座標移動の補間には、デフォルトでスプラインが使用されます。
	(命令のオプションで補間方法を任意に指定することも可能です)

	パラメーターを相対的(もとの値からの差分)に指定したい場合は、
	相対指定オプションを指定します。

		例:
			newevent ev1	; 新しいイベントIDを取得
			event_pos ev1, 20, 10,10,0, 3
			event_wait ev1, 20
			event_pos ev1, 20, 10,-10,0, 3
			event_wait ev1, 20
			event_pos ev1, 20, 10,10,0, 3
			event_wait ev1, 20
			event_pos ev1, 20, 10,-10,0, 3
			event_wait ev1, 20

	上の例では、もとの座標が(0,0,0)にあった場合、
	(10,10,0)→(20,0,0)→(30,10,0)→(40,0,0)の順番に移動を行ないます。

	パラメーター加算とevent_waitイベントを組み合わせることで、
	連続的なパラメーター変化をさせることができます。

		例:
			newevent ev1	; 新しいイベントIDを取得
			event_addpos ev1, 0,1,0
			event_wait ev1, 10
			event_addpos ev1, -1,0,0
			event_wait ev1, 20

	上の例では、最初の１０フレームはYに１を加算し続け、その後
	２０フレームは、X座標を-1し続けることになります。
	さらに、イベントを繰り返し処理させるためにevent_jump命令を
	使用することができます。

		例:
			newevent ev1	; 新しいイベントIDを取得
			event_addpos ev1, 0,1,0
			event_wait ev1, 20
			event_addpos ev1, 0,-1,0
			event_wait ev1, 20
			event_jump ev1, 0, 100

	上の例では、２０フレームごとにY座標を1だけ加算・減算する
	という処理を繰り返し行なうことになります。
	event_jumpは、登録されているイベントリストの中で指定された
	場所に処理を戻します。これにより、永遠に特定の処理をし続ける
	イベントリストを作成することが可能になります。

	event_prmon命令は、オブジェクトの各種パラメーターを設定するための
	イベントを登録します。
	以下のパラメーターIDに、指定された値を直接設定します。

		パラメーターID   内容
		---------------------------------------
		PRMSET_MODE      動作モード
		PRMSET_FLAG      存在フラグ
		PRMSET_SHADE     シェーディングモード
		PRMSET_TIMER     タイマー
		PRMSET_MYGROUP   コリジョングループ値
		PRMSET_COLGROUP  対象グループ値

	PRMSET_MODEは、setobjmode命令で指定する各種フラグの設定を
	イベントから行なうことができます。
	PRMSET_FLAGは、フラグ値を設定することができます。
	フラグ値は、以下の意味を持っています。

		フラグ値    内容
		---------------------------------------
		       1    オブジェクトが有効
		       2    オブジェクトの表示が有効
		       4    オブジェクトの自動移動が有効

	フラグ値は、それぞれの値が加算されたものになります。
	通常、初期化されたオブジェクトのフラグ値は、7になっています。
	また、PRMSET_FLAGに0を設定した場合は、オブジェクトそのものを
	削除します。

		例:
			event_prmset ev1,PRMSET_FLAG,0	; オブジェクト削除

	イベントの最後に自分自身を消去したい場合には、上のような方法で
	削除するようにしてください。

	これにより、ゲーム等で起きる定型の処理(爆発やミサイルの軌道など)を
	イベントリストとしてスマートに分離して管理することができます。
	イベントリストは、非常に応用範囲が広い反面、命令の種類も多く
	最初は難しく感じるかもしれませんが、１つ１つ使いながら覚えて
	いけばスクリプトで行なう手間を大幅に削減することができるはずです。

	setevent命令によって設定されるイベントは、オブジェクト１つ
	あたり４つまで同時に適用することが可能です。

	また、setevent命令によりオブジェクトに設定されたイベントを削除
	することも可能です。詳しくは、命令リファレンスを参照してください。

	ここで挙げた命令以外にも、モードやフラグなどのパラメーターを
	操作するためのイベントなど様々な応用が可能です。
	それぞれの命令の詳細は、ヘルプを参照してください。


・エミッターについて(new)

	エミッターとは、複数のオブジェクトを一度に発生させることのできる
	特別な仕組みです。ランダムなパラメーターなど自由な組み合わせで
	生成することのできる、オブジェクト発生器と考えてください。
	新しくエミッターを作成する場合には、必ずnewemit命令でエミッターIDを
	取得しておく必要があります。
	その後、「emit_」で始まるエミッター設定命令によって多彩な動作を
	登録しておくことができます。
	エミッターが作成されてすぐにオブジェクトが発生するわけではありません。
	あらかじめ、発生条件を色々と設定した上で必要な時に発生させます。
	エミッターを実際に利用する場合は、hgemit命令によっていつでも
	発生させることができるほか、setobjemit命令によりオブジェクトに対して
	適用することも可能です。
	詳しくは、以下のエミッター関連命令のヘルプを参照してください。

	newemit				エミッターを作成
	delemit				エミッターを削除
	emit_size			エミッターの発生範囲を設定
	emit_speed			エミッターのスピード設定
	emit_angmul			エミッターの角度係数を設定
	emit_angopt			エミッターの角度加算値を設定
	emit_model			エミッターの発生モデルを設定
	emit_event			エミッターのイベント設定
	emit_num			エミッターの発生数設定
	emit_group			エミッターのグループ設定
	hgemit				エミッター発生実行
	setobjemit			オブジェクトにエミッター適用


・MOC設定命令について

	MOCとは、MOC(Motion Object Controller)のことで、複数のグループに
	分かれたベクトルパラメーター(x,y,zの値)をまとめて管理する仕組みを
	指しています。

	MOC設定命令は、HGIMG2と互換のある方法でオブジェクトパラメーターの
	操作を行なうための命令セットです。
	通常の利用や、新しくHGIMG3を使い始めるユーザーは、特に覚えなくても
	オブジェクトパラメーターの操作は可能です。

	HGIMG3の「オブジェクト」は、以下のようなパラメータを持っています。
	(「オブジェクトパラメーター設定命令について」のリストと同一です)

		「オブジェクト パラメータ」

		グループ    offset0      offset1     offset2      offset3
		--------------------------------------------------------------
		  A         [X座標]      [Y座標]     [Z座標]      [未使用]
		  B         [X回転角]    [Y回転角]   [Z回転角]    [未使用]
		  C         [X倍率]      [Y倍率]     [Z倍率]      [未使用]
		  D         [X移動量]    [Y移動量]   [Z移動量]    [未使用]
		  E         [α合成値]   [未使用]    [未使用]     [未使用]
		  F         [ワーク値X]  [ワーク値X] [ワーク値X]  [未使用]

	グループA〜Fまでにそれぞれoffset0〜3までのパラメータが存在しています。
	それらのパラメータを更新することで、画面に表示されているオブジェクトにも
	反映されます。
	どのグループを書き換え対象にするかを指定する命令として、

		selpos id		移動座標(グループA)をMOC情報に設定
		selang id		回転角度(グループB)をMOC情報に設定
		selscale id		スケール(グループC)をMOC情報に設定
		seldir id		移動量(グループD)をMOC情報に設定
		selefx id		特殊効果(グループE)をMOC情報に設定
		selwork id		ワーク値(グループF)をMOC情報に設定

	があります。idは、オブジェクトID(番号)になります。
	これらのパラメータを更新するためにMOC設定命令群が用意されています。
	設定するには、まず「どのオブジェクトのどのグループを書き換え対象に
	するか」を指定します。次に、offset0〜3のどの部分を変更するかを指定
	する２段階が必要になります。

	カメラオブジェクトのグループを指定する場合には、

		selcpos			カメラ座標(グループA)をMOC情報に設定
		selcang			カメラ角度(グループB)をMOC情報に設定
		selcint			カメラ注視点(グループC)をMOC情報に設定

	を使用します。

	ライト(光源)オブジェクトのグループを指定する場合には、

		sellpos	id		光源座標(グループA)をMOC情報に設定
		sellang	id		光源角度(グループB)をMOC情報に設定
		sellcolor id		光源色(グループC)をMOC情報に設定

	を使用します。
	また、直接グループを値で設定するための命令として、

		selmoc id, group	オブジェクトのMOCグループ指定
		selcam group		カメラのMOCグループ指定
		sellight id,ofs		光源をMOC情報に設定

	があります。groupは、012…の順番にABC…が割り当てられます。
	グループが指定されたら、次は実際の値を設定します。これには、多様な
	設定方法がありますが、最も単純な方法は、

		objset1 ofs,x					MOC情報を設定

	の命令で、ofsにオフセット番号、xに設定する値を指定することです。
	これで目的のパラメータを任意の値に設定することができます。
	xには、実数または整数値を指定することができます。
	(HGIMG互換のためのobjsetf1も用意されています。)

	さらに、2つのパラメータを同時に設定するための命令、

		objset2 ofs,x,y					MOC情報を設定

	も用意されています。これは、2DスプライトのX,Y座標など2つのパラメータを
	セットで指定する場合に都合のよい命令です。この場合は、指定したオフセット
	とその次のオフセットが設定の対象になります。
	(HGIMG互換のためのobjsetf2も用意されています。)

	そして3つのパラメータを同時に設定するための命令、

		objset3 x,y,z					MOC情報を設定

	も同様に用意されています。ここでは、必ずオフセット0,1,2が設定の対象に
	なります。3D座標などのX,Y,Z値を同時に指定する場合に都合のよい命令です。
	(HGIMG互換のためのobjsetf3も用意されています。)

	これらに加えて、

		objadd1 ofs,x					MOC情報を加算
		objaddf1 ofs,x					MOC情報を加算
		objadd2 ofs,x,y					MOC情報を加算
		objaddf2 ofs,x,y				MOC情報を加算
		objadd3 x,y,z					MOC情報を加算
		objaddf3 x,y,z					MOC情報を加算

	は、対象となるパラメータに記憶されていた値に対して、指定値を加算する
	命令です。加算値にマイナスの値を使うことで、減算をすることも可能です。

	MOC情報を設定するものの中で、パラメーターとして角度を指定する場所で
	使用する専用の命令が用意されています。
	objset1rのように、最後に「r」がついています。
	これは、通常ラジアン単位の角度を指定するべきパラメーターを、整数値で
	指定できるようにしたものです。

		objset1r ofs,x					MOC情報を設定
		objset2r ofs,x,y				MOC情報を設定
		objset3r x,y,z					MOC情報を設定

	これらの命令は、回転情報を0〜255までを１周とする単位で扱うことができます。

	最後にパラメータを変数に取り出したり、逆に変数に後で説明するFV形式
	で格納されている値をパラメータに設定するための命令が用意されています。

		objgetfv fv						MOC情報を取得
		objsetfv fv						MOC情報を設定
		objaddfv fv						MOC情報を加算
		objgetv v						MOC情報を整数値で取得
		objsetv v						MOC情報を整数値で設定

	これらの命令を使うことで、多くのパラメータを効率よく管理、変更する
	ことができるようになっています。


・浮動小数サポート命令

	浮動小数サポート命令は、小数値、ベクトル値などの情報を扱うための
	命令群です。ベクトルを変数に格納する方法としてFV値という表現が出て
	きますが、これは「変数名=1.0」のように1つの値を代入するのではなく
	「変数名.0=X:変数名.1=Y:変数名.2=Z」のように実数型の配列変数として
	3つの要素(X,Y,Z)を格納しておく形式です。

	FV値を使用することで、３次元座標や角度(ベクトル)などの情報を比較的
	整理して扱うことができます。FV値を演算する命令では、同時に3つの要素に
	対して計算されるため、１つの要素ごとに計算するよりもシンプルで高速に
	処理を行なうことができます。

	fvseti fv,x,y,z					整数値からベクトル設定

		fv      = FV値が代入される変数名
		(x,y,z) = 整数値

		(x,y,z)で指定された整数値をベクトルとしてFV値に代入する。

	fvset fv,x,y,z					ベクトル設定

		fv      = FV値が代入される変数名
		(x,y,z) = 実数値

		(x,y,z)で指定された整数値をベクトルとしてFV値に代入する。

	fvadd fv,x,y,z					ベクトル加算
	fvsub fv,x,y,z					ベクトル減算
	fvmul fv,x,y,z					ベクトル乗算
	fvdiv fv,x,y,z					ベクトル除算

		fv      = FV値が代入される変数名
		(x,y,z) = 計算値(実数値)

		fvで指定された変数に格納されているFV値と、指定された
		小数値(X,Y,Z)の演算を並列で行ないます。

	fvdir fv,x,y,z					ベクトル回転

		fv      = FV値が代入される変数名
		(x,y,z) = 回転角度(実数値)

		fvで指定された変数に格納されているベクトル(FV値)を、
		小数値(X,Y,Z)で指定されたX,Y,Z角度に回転させます。

	fvmin fv,x,y,z					ベクトル最大値

		fv      = FV値が代入される変数名
		(x,y,z) = 比較値(実数値)

		fvで指定された変数に格納されているFV値と、
		小数値(X,Y,Z)を比較して、値の大きいものを代入します。
		FV値の各要素を最小値までに切り詰める場合に使用します。

	fvmax fv,x,y,z					ベクトル最小値

		fv      = FV値が代入される変数名
		(x,y,z) = 比較値(実数値)

		fvで指定された変数に格納されているFV値と、
		小数値(X,Y,Z)を比較して、値の小さいものを代入します。
		FV値の各要素を最大値までに切り詰める場合に使用します。

	fvouter fv,x,y,z				ベクトル外積

		fv      = FV値が代入される変数名
		(x,y,z) = 演算するベクトル値(実数値)

		fvで指定された変数に格納されているFV値と、
		小数値(X,Y,Z)で指定するベクトルの外積を求めて代入します。

	fvinner fv,x,y,z				ベクトル内積

		fv      = FV値が代入される変数名
		(x,y,z) = 演算するベクトル値(実数値)

		fvで指定された変数に格納されているFV値と、
		小数値(X,Y,Z)で指定するベクトルの内積を求めてfv.0に代入します。

	fvface fv,x,y,z					座標から角度を得る

		fv      = FV値が代入される変数名
		(x,y,z) = X,Y,Z座標値(実数値)

		fvで指定された変数に格納されているベクトル(FV値)を基点とする
		X,Y,Z座標から、指定されたX,Y,Z座標を直線で見るための回転角度を求めて
		代入します。

	fvunit fv						ベクトル正規化

		fv      = FV値が代入される変数名

		fvで指定された変数に格納されているベクトル(FV値)を正規化します。

	fsin fval,rot					サインを求める

		fval    = float値が代入される変数名
		rot     = 回転角度(実数)

		rotで指定された角度のサイン値をfvalで指定した変数に代入します。
		角度の単位はラジアンになります。

	fcos fval,rot					コサインを求める

		fval    = float値が代入される変数名
		rot     = 回転角度(実数)

		rotで指定された角度のコサイン値をfvalで指定した変数に代入します。
		角度の単位はラジアンになります。

	fsqr fval,prm					平方根を求める

		fval    = float値が代入される変数名
		prm     = 演算に使われる値(実数)

		prmで指定された値の平方根をfvalで指定した変数に代入します。

	froti fval,prm					整数値角度を小数値に変換

		fval    = float値が代入される変数名
		prm     = 0〜1023の角度値(整数)

		prmで指定された整数値(0〜1023)を角度を示すものとして、
		fvalに-π〜+πのラジアン角度値に変換して代入します。

	fv2str fv						ベクトルを文字列に変換

		fvで指定された変数に格納されているベクトル(FV値)を文字列に
		変換してシステム変数refstrに結果を返します。

	str2fv fv,"x,y,z"				文字列をベクトルに変換

		"x,y,z"で指定された文字列情報を「,」で区切られたX,Y,Z小数値として
		読み出し、fvで指定された変数に格納します。

	str2f fval,"val"				文字列を小数値に変換

		"val"で指定された文字列情報を小数値として読み出し、
		fvalで指定された変数に格納します。

	f2str val,fval					小数値を文字列に変換

		fvalで指定された小数値を文字列に変換して、valで指定された文字列型の
		変数に結果を返します。

	f2i v,x,y,z						小数値を整数値に変換

		小数値(X,Y,Z)を整数値に変換して、vで指定された数値型の変数に代入
		します。結果はそれぞれ「v.0=x:v.1=y:v.2=z」の各要素に格納されます。


・DirectXについて

	DirectX使用時の注意点は以下の通りです。

	・DirectX8以上のランタイムがインストールされている必要があります
	・DirectX使用時は常にフルカラーモードが選択されます
	・テクスチャの縦横サイズは2のn乗(2,4,8,16…)に合わせて読み込まれます

	一部のビデオカードでは、テクスチャフォーマットがサポートされていない場合に
	エラーが出ることがあります。HGIMG3で、サポートしているテクスチャ形式は、
	「A8R8G8B8」「X8R8G8B8」「A1R5G5B5」「X1R5G5B5」です。テクスチャは、この中
	の最適なフォーマットに変換して使用されます。
	将来のバージョンではインデックスカラーのテクスチャもサポートする予定です。

	ワンスキンモデルの描画や、トゥーンシェーディングなどの特殊機能は、
	バーテックスシェーダーが使用されます。ビデオカードが、ハードウェア処理
	によるバーテックスシェーダーに対応している場合は、より高速に処理されます。
	ハードウェア処理によるバーテックスシェーダーに対応していない場合でも、
	ソフトウェア処理により正常に描画されます。


・命令リファレンス


	各命令の詳細は、HSPヘルプマネージャーのヘルプファイル(*.hs)として
	提供されています。
	同梱の、「hgimg3.hs」ファイルをHSPがインストールされているディレクトリ
	にある「hsphelp」フォルダにコピーすることで、ヘルプマネージャー
	による検索やワンキーヘルプによるリファレンスが参照できます。


・DirectXフルスクリーンモードについて

	hgsetreq命令によって、SYSREQ_DXMODEのモードに1を指定することで、
	hgini命令で初期化した際にフルスクリーンモードが選択されます。
	フルスクリーン時の解像度は、SYSREQ_DXWIDTH、SYSREQ_DXHEIGHTで指定します。
	現時点では、フルスクリーンとウインドゥモードの動的な切り替えはサポート
	していません。

		例:

		;	初期設定
		;
		bgscr 0,640,480,0		; フルスクリーンは必ずbgscrで作成
		cls 4
		hgsetreq SYSREQ_DXMODE,1		; フルスクリーンモードを指定
		hgsetreq SYSREQ_DXWIDTH,640		; フルスクリーン解像度X
		hgsetreq SYSREQ_DXHEIGHT,480	; フルスクリーン解像度Y
		hgini


・3Dモデルの形式について

	HGIMG3では、x形式の3Dモデルを読み込んで使用することができます。
	x形式は、DirectXの標準的なファイルフォーマットで、3Dモデル情報、ノード情報、
	マテリアルやアニメーションなどの情報が保存されています。

	HGIMG3が読み込むx形式は、DirectX8以降のスキンメッシュに対応しています。
	ワンスキンモデル及びアニメーションを出力可能な各種ツールで、x形式の出力に
	対応したものを別途ご用意下さい。

	プラグインの検証には、主にLightwave7.5のDirectX Exportプラグインによって
	出力されたデータを使用しています。

	※LWのDirectX Exportで出力する場合は、text形式を選択してください。
	※頂点ごとの色設定には対応していません。
	※複数アニメーションを格納したx形式には対応していません。
	※マトリックスによるキー指定(Matrix Key)はフレーム補間が行なわれません。

	アニメーション及びワンスキンモデルの検証には、SOFTIMAGE|XSI Mod Tool
	により出力された.xファイル、及びRokDeBone2が出力する.xファイルでも
	動作を確認しています。

	HGIMG2でサポートされていた、mx形式の3Dモデルデータは、読み込みのみ
	サポートされます。ma形式のアニメーションデータ及び、mx形式の階層情報は、
	HGIMG3では利用することができませんのでご了承下さい。


・日本語フォント描画機能について

	HGIMG3では、フォント描画用のテクスチャを使用して日本語のメッセージを
	表示させることが可能です。DirectXの画面にはmes命令を使用することが
	できず、fprt命令でも英文字のフォントしかサポートされていませんでした。
	フォント描画テクスチャを使用することで、テクスチャを通して日本語を
	自由に描画することができるようになります。
	以下のスクリプトは、実際に日本語フォント描画機能を使用した例です。

	例:

	texmake 256,128		; フォント描画テクスチャの準備
	mest = stat		; テクスチャIDを変数mestに保存
	texcls mest,$004000	; フォント描画テクスチャをクリア
	font "ＭＳ ゴシック",22,1	; フォントの選択
	color 255,255,255		; 描画色を設定
	texmes "日本語メッセージです。",mest,0,0	;(0,0)にフォントを描画

	フォント描画テクスチャは、texmake命令により生成させることが可能です。
	texmake命令は、VRAM上に指定されたサイズのテクスチャエリアを確保します。
	この時、テクスチャのフォーマットをオプションで指定することができます。
	作成モードが0か省略された場合は、16bitテクスチャ(A4R4G4B4)が作成されます。
	作成モードが0以外の時は、32bitテクスチャ(A8R8G8B8)となります。
	16bitテクスチャの方が速度的にも互換性の上でも有利になりますが、より
	高精度なメッセージ描画を行なう場合には、32bitテクスチャを指定してください。

	テクスチャへのフォント描画は、texmes命令によって実行されます。
	この時、color命令により設定された色と、font命令によって設定された
	フォントの情報が参照されます。
	テクスチャへフォント描画を行なっただけでは、画面上にメッセージは表示
	されません。フォント描画テクスチャを何らかのモデルに貼り付けるか、
	grotate命令などで直接画面上に表示を行なう必要があります。
	テクスチャへの描画と、実際の画面上への描画の２段階があるので、注意が
	必要です。テクスチャは、一度描画した内容はそのままなので、毎フレーム
	ごとに同じ内容をtexmes命令で描画する必要はありません。


・テクスチャの形式について

	HGIMG3では、テクスチャ読み込みのために２種類の方法を用意しています。
	１つは、HSPのバッファを介してテクスチャを読み込むtexload命令、
	もう１つは、DirectXのAPIを利用してテクスチャを読み込むtexload2命令です。
	この２種類の命令には、以下のような違いがあります。

	・texload命令

	　HSPの画面バッファを介してテクスチャを登録する(settex命令が使われる)。
	　bmp,jpg,gifフォーマットが利用可能。
	　アルファチャンネルには対応していない。
	　(A8R8G8B8)または、(A1R5G5B5)フォーマットに自動的に変換される。
	　テクスチャサイズが不正な場合は、黒ピクセルを自動的に追加して登録する。

	・texload2命令

	　DirectXのAPIによりテクスチャを登録する。
	　bmp,jpg,gif,png,dds,tga,tiffフォーマットが利用可能。
	　アルファチャンネルに対応している。
	　ピクセルフォーマットは最適なものに自動変換される。
	　テクスチャサイズが不正な場合は、拡大縮小を行なって登録する。

	基本的には、アルファチャンネルを含むテクスチャはtexload2命令で、
	テクスチャの拡大縮小を自動で行なわれては困る場合には、texload命令を
	利用すると良いでしょう。
	x形式のモデルデータで使用されているテクスチャについては、texload2命令
	と同等の動作になります。


・トゥーンシェーディングについて

	x形式のモデルデータにアニメ調の描画処理(トゥーンシェーディング)を
	施すことが可能です。トゥーンシェーディングは、単色のポリゴン部分を
	適切な色に置き換え、輪郭を描画することでアニメ調の表現を行なうものです。
	テクスチャが貼られている部分は、アニメ調のシェーディングは行なわれない
	ので注意してください。

	最も簡単にモデルにトゥーンシェーディングを適用する場合には、
	maketoon命令を使用します。

		例:
		addxfile m_xmodel,"monster.x"
		maketoon m_xmodel,1

	これにより、内部で自動作成されたトゥーンテクスチャ(トゥーン
	シェーディング用に最適化されたテクスチャ)がモデルに適用されます。
	トゥーンテクスチャは、光の強さに対してどのような色で描画を行なうかを
	マテリアル色ごとに示しているもので、１つのモデルに対して１枚の
	トゥーンテクスチャが必要になります。

	「maketoon m_xmodel,2」のように作成モードに2を設定すると、
	「toon.bmp」という名前でトゥーンテクスチャがファイルとして保存されます。
	このファイルを自前で加工することで、トゥーンシェーディングの色使いや
	影の比率などを自由に変化させることができます。
	トゥーンテクスチャは、Y軸は１つのマテリアルにつき８ドット単位で構成
	されており、一番上のドットがもとのマテリアル色を示しています。
	下４ドット(Y=4〜7)までが、トゥーンシェーディング時に実際に描画される
	色の情報になります。この時、光の影響が強いほどX軸が大きくなります。
	(X軸は0が最小で127が最大値となります。)
	自前で修正したトゥーンテクスチャは、loadtoon命令により適用させる
	ことができます。

		例:
		addxfile m_xmodel,"monster.x"
		loadtoon m_xmodel,"t_mons.bmp"

	トゥーンシェーディング時の細かい設定をsettoonedge命令によって行なう
	ことができます。settoonedge命令のパラメーターは以下の通りです。

		settoonedge		トゥーンシェーディング時の設定

		settoonedge p1,p2,p3,p4

		p1    : モデルID
		p2(0) : エッジの色(RGBコード)
		p3(0) : Zオフセット
		p4(0) : Xオフセット

		p1で指定したモデルのトゥーンシェーディング時の設定を行ないます。
		p2で、エッジの色コード(RRGGBB)を指定します。
		p3,p4は実数値によりエッジのオフセットを指定することができます。
		Zオフセット(p3)を変更することにより、輪郭線の太さを調整することができます。
		Zオフセットのデフォルト値は、0.005が設定されています。
		Xオフセット(p4)は、トゥーンシェーディングで使用するテクスチャのX方向原点を指定します。
		Xオフセットのデフォルト値は、0.5が設定されており、この場合はX方向の半分にあたる	位置を中心にして、
		テクスチャのU値が計算されることになります。


・複数アニメーションの切り替えについて

	x形式のモデルデータに対して複数のアニメーションデータを切り替えて
	再生することが可能です。
	まず最初に、モデル全体と最初のアニメーションを含んだデータをaddxfile命令に
	より読み込み、さらに追加でアニメーションだけを登録する場合にaddxanim命令を
	必要な数だけ使用してください。
	複数のアニメーションデータを読み込む場合は、必ずモデルやボーンの構成が同一
	のものから出力されている必要があります。
	以下は、「wait.x」「walk.x」「run.x」という３つのファイルを読み込んでいる
	サンプルです。

		例:
		addxfile m_xmodel,"wait.x" ; アニメーションインデックス0
		addxanim m_xmodel,"walk.x" ; アニメーションインデックス1
		addxanim m_xmodel,"run.x" ; アニメーションインデックス2

	複数のアニメーションを読み込んだ場合は、アニメーションインデックス値が
	0から始まり1,2,3…という順に割り振られていきます。
	アニメーションインデックス値は、objact命令でアニメーションを実際に
	切り替える時に、指定することになります。
	objact命令のパラメーターは以下のようになっています。

		objact ObjID,Anim,mode			指定アニメーションを開始

		ObjID   : オブジェクトID
		Anim    : アニメーションインデックス値
		mode(0) : 設定モード(0=即時/1=終了時)

	先のサンプルの場合は、

		例:
		objact obj,0 ; 「wait.x」を再生
		objact obj,1 ; 「walk.x」を再生
		objact obj,2 ; 「run.x」を再生

	というパラメーターになります。
	objact命令によるアニメーション切り替えでは、設定モードを選択する
	ことができます。

		objact obj,0 ; 「wait.x」を再生

	の場合は、命令が実行された時点で即時に切り替えを行ないます。
	設定モード0でアニメーションを再生した場合は、再生スピードはデフォルト値に
	戻され、リピート再生が行なわれる設定になります。

		objact obj,0,1 ; 「wait.x」を再生

	設定モードに1を指定した場合は、現在再生されているアニメーションが
	終了してから、設定されたアニメーションに切り替わります。

	アニメーションの再生速度は、objspeed命令によって個別に変更する
	ことが可能です。また、getanim命令により現在再生されているアニメーション
	に関する情報を取得することができます。
	詳しくは、objspeed,getanim命令のヘルプを参照してください。


・半透明オブジェクトの描画について

	HGIMG3では、登録された順番(IDの小さい順番)に描画が行なわれます。
	ただし、半透明オブジェクトなどの描画順番を考慮する必要がある場合は、
	オブジェクトのモード設定でOBJ_SORT、またはOBJ_LATEを指定するように
	してください。
	OBJ_SORTが設定されたオブジェクトは、表示時に奥から順番に描画される
	ようにソートが行なわれます。(3Dオブジェクトのみ有効です)
	OBJ_LATEが設定されたオブジェクトは、通常よりも後に描画されます。
	これにより、奥にある物体を遮ることなく半透明の描画を行なうことができます。


・カメラ注視モードの動作について

	hgsetreq命令により、カメラ注視モード時の動作を設定することが可能です。
	HGIMG3.1で、カメラ注視モードの動作が修正されているため、
	以前に作られたスクリプトが正しく動作しないことがあります。
	その場合は、以下のように互換カメラモードを設定するようにしてください。

	例:
	hgsetreq SYSREQ_OLDCAM,1	; HGIMG3.0互換カメラモードを設定


・テクスチャ補間について

	hgsetreq命令により、2D・3D描画時のテクスチャ補間モードを設定することが
	可能です。

		マクロ名          内容(デフォルト値)
		-----------------------------------------------------
		SYSREQ_2DFILTER   2D描画時のテクスチャ補間モード(1)
		SYSREQ_2DFILTER2  2D直接描画時のテクスチャ補間モード(1)
		SYSREQ_3DFILTER   3D描画時のテクスチャ補間モード(2)

	例:
	hgsetreq SYSREQ_2DFILTER,2	; 2D描画時のテクスチャ補間モードを設定

	テクスチャ補間モードは、2D、3D別々に設定が可能です。
	SYSREQ_2DFILTERは、addspr命令等で登録された2Dオブジェクトに適用されます。
	また、SYSREQ_2DFILTER2は、直接描画命令(fprt等)に適用されます。
	フレーム単位に切り替えることも可能ですが、オブジェクト単位での設定はできません。
	設定するモード値は、以下の意味を持っています。

		モード値          内容(DirectXマクロ名)
		-----------------------------------------------------
		   1          ニアレスト(補間なし) (D3DTEXF_POINT)
		   2          バイリニア補間 (D3DTEXF_LINEAR)
		   3          異方性フィルタリング (D3DTEXF_ANISOTROPIC)
		   6          4サンプルテントフィルタ (D3DTEXF_PYRAMIDALQUAD)
		   7          4サンプルガウスフィルタ (D3DTEXF_GAUSSIANQUAD)

	通常の環境であれば、モード値は、1(補間なし)または2(バイリニア補間)の
	どちらかを選択しておくことを推奨します。


・オブジェクトの回転順序設定について

	3Dオブジェクトを表示する際に、XYZ軸の回転を適用する順番を設定
	することができます。
	回転順序設定は、モデル単位で行なうことが可能です。
	modelorder命令の書式は、以下の通りです。

		modelorder モデルID, モード (0〜2)

	モード値は、以下のいずれかになります。


		モード値  マクロ                 回転順序
		------------------------------------------------------
		    0     HGMODEL_ROTORDER_ZYX   Z→Y→X
		    1     HGMODEL_ROTORDER_XYZ   X→Y→Z
		    2     HGMODEL_ROTORDER_YXZ   Y→X→Z


	デフォルトのモデルでは、モード値0が設定されています。
	(ただし、x形式のモデルのみモード値1がデフォルトとなります。)

	modelorder命令は、どうしても解決できないオブジェクトの向きを
	設定する場合や、既存のデータとの互換を取るために用意されています。
	通常、使用する範囲で必須となる命令ではありません。


・シェーディングモードの設定について

	3Dモデルのライティング方法について、いくつかのオプションを選択
	することが可能です。
	modelshade命令は、指定されたモデルIDが持つのシェーディングモードを
	設定します。シェーディングモードは、モデルを表示した時に行なう
	光源計算の方法を示します。
	modelshade命令の書式は、以下の通りです。

		modelshade モデルID, シェーディングモード(0〜2)

	モード値は、以下のいずれかになります。

		モード値      内容
		-----------------------------------------------------
		   0          コンスタント(光源計算なし)
		   1          グーロー(DirectX標準の光源計算)
		   2          半球ライティング

	モード値が0の場合は、光源計算を行なわず常にマテリアル色をそのまま
	反映します。(コンスタントシェーディング)
	モード値が0の場合は、ライト色、アンビエント色を考慮した
	光源計算を行ないます。この場合の表示色は、

		輝度 = 光の強さ * ライト色 * マテリアル色 + アンビエント色

	という式が使用されます。(輝度が255を越えた場合は、255になります。)
	モード値が2の場合は、ライト色を天球色、アンビエント色を地上色として
	半球ライティングの計算が行なわれます。
	半球ライティングは、DirectX標準の光源計算と比べてやわらかで
	きめの細かい陰影を表現することができます。
	現在のバージョンでは、x形式のモデルにのみ半球ライティングを適用する
	ことができます。
	また、シェーディングモード１ではライトのscale(カラー)パラメータは現在反映されない仕様となっていますのでご了承ください。


・アニメーション補間モードについて

	Xファイルモデルアニメーションの補間モードを選択することが可能です。
	補間モードにより、主にボーン変形モデルのキーフレーム間アニメーション
	挙動が変わります。Xファイルを出力したアニメーションツールに合わせて
	選択をしてください。

	以下の書式で設定することで、それ以降に登録されたモデルに反映されます。

		hgsetreq SYSREQ_QUATALG,モード値

		モード0 = QuaternionSlerp (標準的な球面線形補間)
		モード1 = QuaternionSquad (球面三次補間)

	デフォルトでは、

		hgsetreq SYSREQ_QUATALG,0

	の状態になっています。


・エフェクトモデルについて

	HGIMG3では、特殊効果や表現を補助するためのエフェクトモデル生成を
	サポートしています。
	エフェクトモデルは、任意の色を持つ多角形をりん光のような表現とともに
	表示するものです。パラメーターの設定により、様々な形を表現することが
	可能で、追加のファイルやテクスチャ画像を用意することなく、内部で
	形状を生成するため手軽に利用することができます。

	エフェクトモデルは、addeprim命令により生成されます。

	addeprim mdid,EPRIM_CIRCLE	; エフェクトモデルを作成

	上の例では、形状EPRIM_CIRCLEを持つエフェクトモデルを作成して、
	変数mdidにモデルIDを代入します。
	２番目のパラメーターで指定する形状は、以下の４種類が指定できます。

	EPRIM_CIRCLE         円
	EPRIM_CIRCLE2        ギザギザの円
	EPRIM_SQUARE         角の丸い四角形
	EPRIM_FAN            任意の頂点数を持つ多角形

	最初に基本形状を指定した後は、細かいパラメーターをseteprim命令で
	設定することが可能になります。

		seteprim Model,Param,Value

		Model   : モデルID
		Param   : パラメーターID
		Value   : パラメーターに設定する値

	seteprimで指定するパラメーターIDは、以下の値を指定します。

	  ID        内容
	---------------------------------------------------------
	  0         りん光部分のサイズ(実数)
	  1         汎用パラメーター(1)(実数)
	  2         汎用パラメーター(2)(実数)
	  3         汎用パラメーター(3)(実数)
	  4         汎用パラメーター(4)(実数)
	  5         汎用パラメーター(5)(実数)
	  6         汎用パラメーター(6)(実数)
	  7         汎用パラメーター(7)(実数)
	  8         汎用パラメーター(8)(実数)
	  16        頂点カラー(1)(整数によるRGBA値指定)
	  17        頂点カラー(2)(整数によるRGBA値指定)
	  18        頂点カラー(3)(整数によるRGBA値指定)
	  19        頂点カラー(4)(整数によるRGBA値指定)

	汎用パラメーター1〜8や、頂点カラー1〜4は、基本形状により役割が
	変化します。
	また、りん光部分のサイズは常に0.2がデフォルトとして設定されます。

	頂点カラーを指定する場合は、整数によるRGBA値となります。
	RGBAを8bitづつ32bitで示したもので、16進数では0xaarrggbbのように
	指定します。
	(たとえば、0xff123456の場合は、A(α値)=ff、R=12、G=34、B=56)

	頂点カラー(1)〜(4)では、りん光を含むそれぞれの頂点色を設定します。
	デフォルトでは、以下の色コードが設定されます。

		頂点カラー(1) : 0xffffffff(白)
		頂点カラー(2) : 0xff00ffff(水白)
		頂点カラー(3) : 0xff0000ff(青)
		頂点カラー(4) : 0x00000080(透明な紺色)

	頂点カラーでは、α値(透明度)が有効になっていることに注意してください。
	α値が0の場合は、完全な透明となります。0xff(255)が完全な不透明です。
	これらの値を上手く利用することで、ぼんやりと光っている表現などの
	特殊効果に役立ちます。半透明を含むモデルを表示する場合には、
	オブジェクトのモードに、OBJ_LATE(常に後から描かれる設定)を追加する
	ようにしてください。また、エフェクトは多くの場合2D的な表現として
	使用するため、OBJ_XFRONT(常に画面に正面を向く)のモードも設定する
	必要が出てくるでしょう。

	それぞれの形状に対応したパラメーターの詳細は、以下の通りです。

	・EPRIM_CIRCLE(円)

		EPRIM_CIRCLEは、設定された頂点数の円を描画します。
		XY方向の倍率を変えることで楕円にすることが可能です。

		汎用パラメーター(1) : 頂点数(デフォルト:20)
		汎用パラメーター(2) : X方向の倍率(デフォルト:1.0)
		汎用パラメーター(3) : Y方向の倍率(デフォルト:1.0)

	・EPRIM_CIRCLE2(ギザギザの円)

		EPRIM_CIRCLE2は、円(16角形)を描画します。
		その中で、４つの半径を自由に指定することができ、
		それを４回繰り返して円が一周することになります。
		これにより、ギザギザした形や歯車のような形状を
		表現することができます。

		汎用パラメーター(1) : 半径1(デフォルト:1.0)
		汎用パラメーター(2) : 半径2(デフォルト:0.5)
		汎用パラメーター(3) : 半径3(デフォルト:1.0)
		汎用パラメーター(4) : 半径4(デフォルト:0.5)

	・EPRIM_SQUARE(角の丸い四角形)

		EPRIM_SQUAREは、角の丸い四角形を描画します。
		４箇所の頂点に対するXYサイズを指定して様々な形状を
		表現することが可能です。

		汎用パラメーター(1) : 頂点X1(デフォルト:0.4)
		汎用パラメーター(2) : 頂点Y1(デフォルト:0.1)
		汎用パラメーター(3) : 頂点X2(デフォルト:0.5)
		汎用パラメーター(4) : 頂点Y2(デフォルト:0.1)
		汎用パラメーター(5) : 頂点X3(デフォルト:0.5)
		汎用パラメーター(6) : 頂点Y3(デフォルト:0.5)
		汎用パラメーター(7) : 頂点X4(デフォルト:0.5)
		汎用パラメーター(8) : 頂点Y4(デフォルト:0.5)

	・EPRIM_FAN(任意の頂点数を持つ多角形)

		EPRIM_FANは、任意の頂点数を持つ多角形を描画します。
		パラメーターの設定により半円を表現することができます。

		汎用パラメーター(1) : 中心からの距離(デフォルト:1.0)
		汎用パラメーター(2) : 開始角度(0.0〜1.0)(デフォルト:0.75)
		汎用パラメーター(3) : 全幅角度(0.0〜1.0)(デフォルト:0.5)
		汎用パラメーター(4) : 頂点数(デフォルト:12)

	seteprim命令により、生成パラメーターを変更した後は、表示を行なう際に
	頂点座標の再構築が行なわれます。
	処理の負荷を軽減するためには、毎フレームごとにseteprim命令を実行する
	のは避けて、必要な場合にのみパラメーター変更を行なうようにしてください。
	event_eprim命令により、seteprimの指定をイベントリストに埋め込む
	ことが可能です。これにより、時間経過でパラメーターの変化する
	エフェクトモデルを登録することができます。


・メッシュマップについて

	HGIMG3.2から、メッシュマップによる地形生成及びコリジョン検知の
	機能がサポートされています。
	これは、addmesh命令によって作成されたメッシュモデルに高さの情報を
	付加したり、特定のテクスチャをパーツとして地面の地形を表現することを
	可能にするものです。これにより、凹凸のある地面にそってキャラクタを
	移動させたり、地形のテクスチャを手軽に生成することができます。
	また、簡易的な物理演算をサポートしており、地形の傾きに応じた物体の
	反発や落下などをシステム側で処理することが可能になっています。

	■２次元配列によるメッシュマップ情報

	メッシュマップでは、整数型の２次元配列により高さを始めとする情報を
	設定することが可能です。これをメッシュマップ情報と呼んでいます。
	通常は、メッシュの頂点ごとの高さを設定し、起伏のある地面を作成する
	ことに使用します。それ以外にも、X,Y,Z座標の情報更新や、UV座標などの
	設定にも対応しています。
	メッシュマップ情報の設定は、meshmap命令により行ないます。

		meshmap var,モデルID,0,0.1

	上の例では、varとして指定された変数に格納されている２次元配列の
	メッシュマップ情報を、モデルIDで指定したメッシュマップに設定します。
	その際に、整数値を0.1倍したものをY座標(高さ)として適用します。

	メッシュマップの分割数よりも、２次元配列の要素サイズが常に１つ多く
	なることに注意してください。たとえば、１０×１０に分割されたメッシュ
	マップの頂点数は、１１×１１になります。つまり２次元配列としては、
	「dim var,11,11」のように頂点数のサイズで初期化する必要があります。

	■画像マップの使用

	グレースケールの画像情報をもとに、メッシュマップ情報を作成する機能が
	用意されています。これにより、メッシュマップの起伏を画像データから作成
	することが可能です。
	メッシュマップ情報の作成は、getvarmap命令によって行ないます。

		getvarmap var,30,30,0

	上の例では、参照元画像(HSPの描画画面上の情報)を３０×３０の領域に
	分割し、変数varに結果を代入します。
	(実際に作成される頂点の数としては、３１×３１になります。)

	■画像マップによる地形データの生成

	画像マップからのメッシュマップ情報生成機能を応用することで、地面に
	表示されるテクスチャUVを手軽に作成することができるようになります。
	これは、あらかじめ決められた要素(地面、道、水面)を４つに分割して
	描かれたテクスチャを適切にメッシュマップ上に貼り付けるものです。
	道や水面の部分を示した画像をもとにマップに反映させることができます。

		sx=32:sy=32			; メッシュ分割サイズ
		dim vmap,sx+1,sy+1		; メッシュマップ情報の変数
		setuv 0,0,256,256		; テクスチャを指定(ダミー)
		addmesh m_mesh,sx,sy,0,160,160	; モデル登録(地面)
		texload "mapbg4.bmp"		; 地面のテクスチャ
		buffer 3			; 読み込み用にHSPのバッファを用意
		picload "g_road.bmp"		; 道の位置を示す画像
		getvarmap vmap,sx,sy,1		; 道の位置を変換
		picload "g_river.bmp"		; 水の位置を示す画像
		getvarmap vmap,sx,sy,2		; 水の位置を変換
		meshmap vmap,m_mesh,$100	; メッシュマップを設定
		gsel 0				; 描画先を戻しておく

	上の例では、「g_road.bmp」「g_river.bmp」という画像をもとに、
	３２×３２に分割されたメッシュマップに地形テクスチャ(mapbg4.bmp)を
	自動的に貼り付けます。

	■メッシュマップ上の移動

	起伏のあるメッシュマップ上にオブジェクトを配置して、手軽に移動させる
	ことが可能です。
	まず、地面として認識されるオブジェクトには、モードとしてOBJ_GROUNDを
	あらかじめ設定しておく必要があります。
	そして、地面の上に配置されるオブジェクトには、モードとしてOBJ_STANDを
	設定します。
	これらの設定を行なった上で、objwalk命令により移動させることで、
	メッシュマップを地面として認識し、起伏に沿った座標が設定されます。
	objwalk命令は、以下の書式で記述します。

		objwalk 変数,オブジェクトID,px,py,pz

	オブジェクトIDで指定したオブジェクトを、(px,py,pz)で指定した方向
	(ベクトル)に移動させます。起伏がある場合は、その上に乗る形で移動を
	行なうほか、障害物なども考慮されます。
	最初のパラメーターで指定された変数には、実際に移動した大きさ(ベクトル)
	が代入されます。(変数は、double型の配列として要素0〜2に値が代入されます)

	これに関連して、地面の上を移動する際に表示されるオブジェクトのY座標に
	対するオフセット値が設定できるようになっています。
	これは、地面にあたる座標から指定された値だけ上方向にずらして表示を
	行なうための機能です。モデルの中心座標によっては、地面に埋まってしまう
	ことがあるのを回避します。

		objfloor オブジェクトID, オフセット値

	上の例では、指定したオブジェクトIDをオフセット値(実数)だけ上にずらして
	表示させる設定を行ないます。

	objwalk命令による移動時に得られる様々な情報をgetcolvec命令により
	取得することが可能です。現在のオブジェクトが接地している地面の情報や
	傾きなどに関するパラメーターを参照することができます。
	詳しくは、getcolvec命令のリファレンスをご覧下さい。

	■拡張コリジョン(障害物)

	objwalk命令による移動時には、地面として認識されるメッシュマップの他に
	障害物として認識されるオブジェクトが考慮されます。
	これを拡張コリジョンと呼び、通常の衝突判定(getcoli命令)とは異なる
	パラメーターを設定することができます。

	オブジェクトを障害物として認識させるためには、以下の準備が必要です。

		・OBJ_STATICモードの設定
		・拡張コリジョンパラメーターの設定
		・コリジョングループの設定

	まず、障害物となるオブジェクトは、モードとしてOBJ_STATICを指定する
	必要があります。次に、拡張コリジョンパラメーターを設定します。
	これは、オブジェクトの衝突判定を取るためのサイズや反発に関する設定を
	するためのもので、modelcols命令、またはsetcolscale命令を使用します。
	現在のパージョンでは、障害物はすべて円柱形の物体として認識されます。
	(将来のバージョンではより複雑な形状が認識可能になる予定です。)
	最後に、コリジョングループの設定を行なう必要があります。
	これは、従来の衝突判定でも行なっていたように、オブジェクトが所属する
	グループと、衝突の対象となるグループを決めるものです。
	衝突の対象となるコリジョングループが設定されていない場合は、障害物と
	して認識されません。

	これらの情報をもとに、オブジェクトの移動時に障害物との衝突を検知して
	適切な回避を行ないます。
	障害物との衝突では、オブジェクトごとの重さ(反発力)を考慮して、他の
	物体を押し出して移動を行ないます。

	■オブジェクト自動移動と重力計算

	HGIMG3では通常、オブジェクトのモードにOBJ_MOVEを指定した場合、
	自動的にdirグループの移動量が座標に加算されます(自動移動モード)。
	オブジェクトのモードにOBJ_STANDが指定されている場合、つまり地面の
	上を移動する状態では、OBJ_MOVEの指定も地面の上を移動する仕様となり
	ます。(objwalk命令と同様の動作を毎フレーム自動的に行ないます。)
	さらに、オブジェクトのモードにOBJ_GRAVITYを付加した場合、
	地面の傾きや障害物を考慮した上での重力計算が自動的に行なわれ、
	dirグループの移動量として設定されます。つまり、傾いた地面の上に
	配置されているオブジェクトは、自動的に地面をすべり落ちて行く
	ことになります。障害物や地面に当たった場合も、反発を行ないます。
	(これは、あくまでも速度を優先した簡易的な重力計算となっているため、
	厳密な物理法則とは異なる可能性があります。)
	重力計算に関するパラメーターの一部は、hgprm命令により設定することが
	できます。

		hgprm 4, 0.5			; バウンド係数
		hgprm 5, 1.0, 0.95		; 抵抗(空中、地上)

	上の例では、地面でのバウンド係数や空気抵抗による摩擦の値を設定
	しています。

	■範囲クリップ

	地面の上を移動させる場合は、必ずメッシュマップの範囲内にいるように
	心がけてください。認識するべき地面がない場合は、そのまま通常移動
	が行なわれます。落下する物体は、永遠に落下をし続けることになって
	しまいます。
	このような現象を回避するために、範囲クリップ機能が付加されています。
	これは、X,Z軸に関する移動範囲を限定するためのものです。
	オブジェクトのモードにOBJ_WALKCLIPを指定した場合、setborder命令で
	設定されたX,Zクリップ範囲から外に出ることができなくなります。
	Y方向については、下限は地面のメッシュマップにより設定されますが、
	上方向の限界をhgprm命令により決めることが可能です。

		hgprm 2,-80			; 移動可能高度

	上の例では、Y座標が-80までしか上方向に移動ができなくなります。

	■自動追尾カメラ

	起伏のあるメッシュマップ上でキャラクターを捉えながらカメラを動かす
	場合、障害物や地面の高さを考慮する必要がありプログラムが非常に
	複雑になります。
	HGIMG3.2から、新しいカメラのモードとして、メッシュマップ及び障害物を
	考慮して適切に目的のオブジェクトを追いかける自動追尾モードが追加
	されています。自動追尾モードでは、カメラの注視点に任意のオブジェクト
	を指定した上で、カメラ自身のコリジョンを設定し、障害物との衝突や
	地面に埋まるといった状態を回避します。
	これにより、三人称視点のゲームなどの作成が手軽になります。
	自動追尾モードは、以下の書式で設定します。

		cammode CAM_MODE_AUTOMOVE, オブジェクトID

	上の例では、オブジェクトIDで指定されたオブジェクトを自動追尾する
	ことになります。
	自動追尾モード時には、オブジェクトの持つworkグループに対象との距離や
	地面からの高さ、さらにdirグループに対象座標のオフセット値を入れて
	おくことができます。

		setdir HGOBJ_CAMERA, x, y, z

	上の例では、自動追尾する対象のオブジェクト座標の注視点に対して、
	(x,y,z)を加算します。これにより、対象オブジェクトの中で注視する
	位置を細かく調整することができます。

		setwork HGOBJ_CAMERA, camdist, camrotate, camheight

	上の例では、camdistとして対象オブジェクトからの距離、camheightとして
	カメラの高さを指定しています。
	camrotateは、特殊なパラメーターで0以外を指定すると、次回の自動追尾
	時に指定した値だけ視点を回転させます。回転後は、camrotateパラメーター
	は0にリセットされます。これは、ユーザーが任意に視点を回転するために
	設けられたオプションで、通常は設定する必要はありません。

	自動追尾モードは、メッシュマップ上を移動する際だけでなく、特定の
	オブジェクトを注視するカメラのモードとして汎用的に利用できます。
	また、自動移動を行なわないで特定のオブジェクトのみを注視するための
	CAM_MODE_LOOKOBJモードも追加されています。

	■波紋生成機能

	メッシュマップに付随して、波紋生成機能がサポートされています。
	これは、任意のサイズに区切られた格子の高さ情報を元に、波紋の伝達や
	弾性の計算を行なうものです。ただし、厳密な物理演算を行なっている
	わけではなく、パフォーマンスを優先した簡易的なレベルに計算量が
	抑えられています。これらの機能は、画面上の演出や効果などに利用する
	ことができます。

	波紋生成機能は、以下の手順で使用します。
	まず、格子の初期化とメッシュの高さ情報を格納する配列変数を作成して
	おく必要があります。

		sx=32:sy=32
		dim vmap,sx+1,sy+1
		wave_init sx,sy

	上の例では、32×32のグリッドが生成されます。
	配列変数は、必ず整数型でグリッドサイズよりもX,Yともに1つ大きい値で
	初期化することに注意してください。(頂点の数はグリッドの分割数より１つ
	多くなるためです)
	初期化された格子は、以下の命令で高さを設定することが可能です。
	(配列変数は、バッファ情報の読み出しとしてのみ使用されます。
	配列変数そのものに代入しても、内部のバッファは更新されません。)

		wave_set 4,5,100

	上の例では、格子(4,5)に高さ100を設定します。
	高さ情報は、整数で指定します。

	実際の演算は、wave_apply命令実行時に行なわれます。

		wave_apply vmap,1

	この例では、設定された格子の弾性計算を行なった上で、変数vmapに
	結果を代入します。

		wave_apply vmap,2

	上の例では、波紋の計算を行なった上で、変数vmapに結果を代入します。
	(波紋の計算は、必ず毎フレーム呼び出して更新するようにしてください。)

	計算結果が代入された配列変数をメッシュマップに反映させるため、
	最後にmeshmap命令を実行させる必要があります。

		meshmap vmap,m_mesh,0,0.1

	上の例では、vmapに代入された配列変数の値をもとに、
	m_meshに代入されたモデルIDのメッシュマップに高さを設定します。
	vmapの内容は、整数型ですが４番目のパラメーターで倍率を0.1と指定
	しているため、実際には１０分の１になった値が設定されます。


・オブジェクト汎用ユーザー情報について

	HGIMG3.2から、すべてのオブジェクトに汎用的なユーザー情報を付加する
	ことができるようになりました。
	これは、ユーザーが自由に保存、参照することができる3つの整数値と
	なります。オブジェクト固有の情報を複数保存する必要がある場合などに
	自由に使うことができます。

	オブジェクト汎用ベクトル情報は、

		setcolscale オブジェクトID, x, y, z, 2

	で設定されます。(x,y,zは任意の整数値)
	設定された内容を参照する場合は、

		getcolvec v1,v2,v3,オブジェクトID,18

	のように指定します。
	この例では、変数v1,v2,v3にユーザー情報が代入されます。


・サウンド関連サポートについて

	3.1β5版から、基本的なサウンド再生機能をHGIMG3に内包しています。
	ゲーム等での効果音再生などをプラグインの追加なしで行なうことが可能です。
	通常は、サウンド関連機能は使用されません。
	dmmini命令により初期化が行なわれた時のみ、サウンド機能が有効となります。
	HGIMG3使用時でも、サウンド関連機能の初期化が行なわれない場合は、
	DirectSoundなどサウンドに関するAPIが使用されることはありません。
	HGIMG3と他のサウンド関連プラグインを使用する場合は、通常通りお使い頂けます。

	サウンド再生機能のために以下の命令が用意されています。

		dmmini		サウンド機能初期化
		dmmbye		サウンド機能終了処理
		dmmreset	サウンド機能の設定をリセット
		dmmdel		サウンドデータを削除
		dmmvol		サウンドデータの音量設定
		dmmpan		サウンドデータのパン設定
		dmmloop		サウンドデータのループ設定
		dmmload		サウンドデータの読み込み
		dmmplay		サウンドデータの再生
		dmmstop		サウンドデータの再生停止
		dmmstat		サウンドデータの状態取得

	命令の詳細は、ヘルプを参照してください。
	サウンド関連機能は、3D機能と同様にDirectX8以降のDirectSoundを
	使用しています。HSP3の内蔵マルチメディア機能と比較して、
	音量の設定や、複数音声の同時再生、状態の取得などを利用することが
	できるようになります。


・登録の限界数について

	登録するオブジェクト数や、モデル数が足りない場合は、別途
	hgsetreq命令により最大数を設定する必要があります。
	以下の例は、オブジェクト最大数を1024に設定します。

	hgsetreq SYSREQ_MAXOBJ,1024	; オブジェクト最大数を拡張する

	hgsetreqで設定できる主な項目は以下の通りです。

		マクロ名          内容
		-----------------------------------------------------
		SYSREQ_MAXMODEL   モデル最大数
		SYSREQ_MAXOBJ     オブジェクト最大数
		SYSREQ_MAXTEX     テクスチャ最大数
		SYSREQ_DXMODE     フルスクリーンモードスイッチ
		SYSREQ_DXHWND     ウィンドウハンドル(参照のみ)
		SYSREQ_DXWIDTH    フルスクリーンモード時の横サイズ
		SYSREQ_DXHEIGHT   フルスクリーンモード時の縦サイズ
		SYSREQ_COLORKEY   テクスチャ登録時の透明色コード
		SYSREQ_RESVMODE   エラー発生時の原因コード(参照のみ)
		SYSREQ_MAXEVENT   イベント最大数
		SYSREQ_MDLANIM    モデルあたりのアニメーション最大数
		SYSREQ_CALCNORMAL Xファイルモデル法線再計算スイッチ
		SYSREQ_2DFILTER   2D描画時のテクスチャ補間モード
		SYSREQ_3DFILTER   3D描画時のテクスチャ補間モード
		SYSREQ_OLDCAM     カメラ注視モードの動作
		SYSREQ_QUATALG    Xファイルモデルアニメーション補間モード
		SYSREQ_DXVSYNC    フルスクリーンモード時のVSYNC待ちモード
		SYSREQ_DEFTIMER   hgsyncの時間待ちモード(0=HGIMG3/1=await)
		SYSREQ_NOMIPMAP   テクスチャのMIPMAP生成モード(0=自動/1=MIPMAPなし)
		SYSREQ_DEVLOST    DirectXデバイスの存在フラグ(0=存在/-1=ロスト)
		SYSREQ_MAXEMITTER エミッター最大数
		SYSREQ_THROUGHFLAG　X方向のボーダー処理フラグ(0=通常/1=スルー)
		SYSREQ_OBAQMATBUF OBAQ用マテリアルバッファ数
		SYSREQ_2DFILTER2   2D直接描画時のテクスチャ補間モード
		SYSREQ_FPUPRESERVE FPU演算精度設定オプション(0=単精度/1=変更なし)
		SYSREQ_DSSOFTWARE  ソフトウェアサウンドバッファの使用(1=ON,0=OFF)
		SYSREQ_DSGLOBAL    グローバルサウンドフォーカス(1=ON,0=OFF)
		SYSREQ_DSBUFSEC    oggストリーム再生バッファのサイズ(秒数)

	HGIMG2.61までに存在したパケットサイズは廃止されています。
	主に使用する項目のデフォルト値は、以下の通りです。

		マクロ名          内容(デフォルト値)
		-----------------------------------------------------
	        SYSREQ_MAXMODEL   モデル最大数(4096) 
	        SYSREQ_MAXOBJ     オブジェクト最大数(512) 
	        SYSREQ_MAXTEX     テクスチャ最大数(512) 
	        SYSREQ_DXMODE     フルスクリーンモードスイッチ(0) 
	        SYSREQ_DXWIDTH    フルスクリーンモード時の横サイズ(640) 
	        SYSREQ_DXHEIGHT   フルスクリーンモード時の縦サイズ(480) 
	        SYSREQ_COLORKEY   テクスチャ登録時の透明色コード(0) 
	        SYSREQ_MAXEVENT   イベント最大数(512) 
	        SYSREQ_MAXEVENT   イベント最大数(512) 
	        SYSREQ_MDLANIM    モデルあたりのアニメーション最大数(16) 
	        SYSREQ_CALCNORMAL Xファイルモデル法線再計算スイッチ(0) 
		SYSREQ_FPUPRESERVE FPU演算精度設定オプション(0)
		SYSREQ_DSSOFTWARE  ソフトウェアサウンドバッファの使用(1)
		SYSREQ_DSGLOBAL    グローバルサウンドフォーカス(1)
		SYSREQ_DSBUFSEC    oggストリーム再生バッファのサイズ(2)


・DirectXパラメーターの参照について

	hggetreq命令により、いくつかのDirectXに関するパラメーターを
	取得することが可能です。

		マクロ名          内容
		-----------------------------------------------------
		SYSREQ_RESULT     エラー発生時の原因コード(参照のみ)
		SYSREQ_RESVMODE   ステータスコード(参照のみ)
		SYSREQ_PTRD3D     DIRECT3D8のCOMポインタ(参照のみ)
		SYSREQ_PTRD3DDEV  DIRECT3DDEVICE8のCOMポインタ(参照のみ)

	SYSREQ_RESULT

		エラー発生時の原因コードが格納されます。
		hgini命令で初期化した場合に、エラーとなった場合に
		参照することで、エラーを特定できる場合があります。

		1 : DIRECT3D8の取得に失敗した
		2 : GetAdapterDisplayModeに失敗した
		3 : DIRECT3DDEVICE8の取得に失敗した

	SYSREQ_RESVMODE

		初期化後にステータスコードが格納されます。
		bit0-7は、D3DFORMAT値(DirectX SDKを参照)を示しています。
		初期化された画面のピクセルフォーマットを知ることができます。
		bit12が1($1000)だった場合は、DirectXがエミュレーション
		モード(D3DDEVTYPE_REF)で動作していることを示しています。

	SYSREQ_PTRD3D
	SYSREQ_PTRD3DDEV

		HGIMG3内部で使用しているDirectXのCOMポインタが格納されます。
		それぞれ、DIRECT3D8と、DIRECT3DDEVICE8のCOMポインタを
		示しています。HSP3のCOM呼び出し機能と組み合わせて
		使用することで、DirectX APIを直接利用することが可能です。


・OggVorbisストリーム再生について

	OggVorbis形式は、ライセンスフリーの圧縮音声ファイルフォーマットです。
	mp3形式などに比べて、ライセンスの問題がなく、OS環境に左右されずに
	使用できる点で、ゲーム等の組み込み形式に向いています。
	HGIMG3では、拡張子「.ogg」を持つファイルをストリームにより再生する
	ことが可能なほか、任意のポイントへのシームレスなループをサポート
	しています。これにより、非常に高音質な音楽を手軽に組み込むことが
	できるようになっています。
	OggVorbis形式ファイルの作成やエンコードの詳細については、サポートを
	行なっていませんので、別途資料やツールをご用意下さい。

	3.32RC1版から、oggストリーム再生バッファの設定をhgsetreq命令で
	行なうことができるようになっています。以下は設定の例です。

	hgsetreq SYSREQ_DSBUFSEC,2	; ストリームバッファのサイズ(秒数)
	hgsetreq SYSREQ_DSGLOBAL,1	; フォーカス外でもサウンドを再生するフラグ(1=ON,0=OFF)
	hgsetreq SYSREQ_DSSOFTWARE,1	; ソフトウェアバッファを使用するフラグ(1=ON,0=OFF)

	上で示した値が、デフォルトで設定されている値となります。
	DirectXのサウンドバッファは、ハードウェアサウンドバッファと
	ソフトウェアサウンドバッファが用意されており、ハードウェアでミキシングが
	可能なデバイスでは、自動的にハードウェアが設定されるようになっています。
	3.32RC1以前のバージョンでは、ハードウェアサウンドバッファを使用する設定に
	なっていましたが、3.32RC1版以降ではソフトウェアサウンドバッファを使用する設定に
	変更されています。
	この設定は、アプリケーションごとの音の再生をミキシングする際に、ハードウェア側の
	支援を受けるか、あるいはCPUが処理するかの違いになりますが、Windows Vistaから
	アプリケーションごとのサウンド管理方法が変更になったため、ソフトウェアサウンドバッファを
	使用することが推奨されています。最近の高速なCPUであれば、ソフトウェアサウンドバッファで
	あってもそれほど重い処理になるとは考え難いですが、逆に古いマシンやWindows XP以前の
	OSなどで負荷を軽減させるなどの特別な目的があれば、ハードウェア側に処理を任せるように
	してみてください。


・OBAQサポート機能について

	OBAQ(物理エンジン)プラグインと連携して、表示のサポートを行なう機能が
	追加されています。
	OBAQプラグインでは、通常HSPのウィンドウ上に描画を行ないますが、
	OBAQが管理するオブジェクトはそのままで、描画のみHGIMG3がDirectXで
	行なう形になります。
	OBAQプラグイン単体で描画した場合に比べて、非常に高速で精度の高い表示
	を実現することができます。
	HGIMG3からOBAQを利用する場合は、必ず以下の順番でヘッダを読み込んで
	ください。

		#include "hgimg3.as"
		#include "obaq.as"

	次に、以下の順番で初期化を行なってください。
	HGIMG3にOBAQ側のデータポインタを渡すことで、連携させます。

		;	初期設定
		;
		hgini
		qreset			; OBAQの初期化
		qgetptr obaq_ptr
		hgobaq obaq_ptr, 0

	描画のメインループは以下のような形になります。

	*main
		;	描画メイン
		;
		qexec			; OBAQによるオブジェクトの更新
		hgdraw			; 描画処理
		hgsync 10		; 時間待ち
		goto *main

	OBAQプラグイン側の描画命令(qdraw)は必要ありません。
	物理動作を行なうためのqexecは必ず含めるようにしてください。
	後は、OBAQ側の命令でオブジェクトの設定を行なえば、自動的にHGIMG3
	の描画プロセスで表示されます。

	OBAQプラグインは、2Dベースの処理を行なっているため平面への
	描画だけしか行なうことができません。
	ただし、HGIMG3上の3Dポリゴン板にOBAQの画面を貼り付けて描画する
	ための3Dモードが用意されています。
	その場合は、以下のように初期化を行なってください。

		;	初期設定
		;
		hgini
		qreset			; OBAQの初期化
		qgetptr obaq_ptr
		hgobaq obaq_ptr, 0, 1	; 3Dモード

		;	OBAQモデル
		;
		addobaq3d m_obaq
		regobj obj, m_obaq
		setscale obj, 0.25,0.25,0.25

	addobaq3d命令により、OBAQを描画するモデルが追加されます。
	これをオブジェクトとして登録することで、3D上の任意の位置、角度で
	描画することができます。
	OBAQ3Dモード時は、OBAQオブジェクトのデバッグ表示が無効になりますので、
	必ずqmat命令でmat_wire等のマテリアルを設定するようにしてください。

	HGIMG3上では、OBAQプラグインの持つ描画方法(マテリアル)に加えて、
	テクスチャを使用して線を描画するモード(mat_wire3)が追加されています。
	これにより、単純な線だけでなく装飾された線や太い線などを描画することが
	可能になっています。この場合は、

		qmat OBAQオブジェクトID, mat_wire3, テクスチャID, セルID
		qmat2 OBAQオブジェクトID, 0,0, 0, 線の太さ

	のような指定になります。qmat2に指定するzoomyパラメーターにより線の
	太さを可変させることができます。以下は「line.tga」というテクスチャを
	使って線を描画するスクリプトの例です。


		;	線テクスチャの準備
		;
		texload2 "line.tga"
		lntex = stat

		;	OBAQ枠線
		;
		qmat 0,mat_wire3,lntex
		qmat2 0, 0,0, 0,16	; 線の太さ(zoomy)


・FPU精度設定オプションについて

	DirectX初期化時に、浮動小数演算ユニット(FPU)の精度がfloat(32bit)に
	設定されます。これにより、通常double(64bit)で演算されていたものも
	32bit精度に落とされてしまいます。これは、多数のデータを高速に扱う
	ためのもので、多くのアプリケーションでも同様の設定になっています。
	ただし、HSP上で精度の高い計算を行ないたい場合や、物理エンジンOBAQを
	通常のHSP3上で動作させた時と同じ精度で結果を得たい時には、
	FPU精度設定オプションの設定をそのままにしておくことが可能です。
	hgsetreq命令によりシステムリクエストで、SYSREQ_FPUPRESERVEに1を設定
	することで、通常の精度で計算が実行されます。(ただし、処理速度が低下
	します)

		hgsetreq　SYSREQ_FPUPRESERVE,1
		hgini


・サウンドに関する詳細設定について

	サウンドの再生機能に関する詳細設定をhgsetreq命令で行なうことが可能です。
	hgsetreq命令には、以下の設定項目が用意されています。

	・SYSREQ_DSSOFTWARE

	ソフトウェアサウンドバッファの使用を設定します(1=ON,0=OFF)
	(デフォルトは1=ONです)
	ソフトウェアサウンドバッファは、CPUによるサウンドのミキシングを
	行なうための設定です。「0=OFF」を設定することにより、ハードウェアの
	ミキシングが有効になります。これは、古いハードウェアやOS上での
	CPU負荷低減につながります。
	Windows Vista以降はソフトウェアサウンドバッファを使用することが
	推奨されています。通常はデフォルト(1=ON)で問題ありません。

	・SYSREQ_DSGLOBAL

	グローバルサウンドフォーカス(1=ON,0=OFF)
	(デフォルトは1=ONです)
	グローバルサウンドフォーカスは、アプリケーションのウインドウが有効
	(フォーカスされている)場合のみサウンドを再生するかを設定します。
	デフォルト(1=ON)では、グローバルサウンドフォーカスは有効となり、
	常にサウンドが再生される状態となります。
	「0=OFF」を設定することにより、アプリケーションのウインドウが
	フォーカスされていない時にはサウンドも再生されない状態となります。

	・SYSREQ_DSBUFSEC

	oggストリーム再生バッファのサイズ(秒数)
	(デフォルトは2です)
	oggストリームを再生するための内部バッファのサイズを指定します。
	デフォルトでは2(秒)となっています。通常は、変更する必要ありませんが、
	ファイルアクセスを抑えたい場合や負荷を軽減するためにより長い時間を
	割り当てる際に設定してください。
	長い秒数を指定すれば、それだけメモリが多く消費されます。

	----------------------------------------------------------------------

	サウンドの詳細設定は、必ずdmmini命令を実行する前に設定を行なってください。
	dmmini命令が実行された時点で、内容が反映されます。

		hgsetreq SYSREQ_DSBUFSEC,2	; ストリームバッファのサイズ(秒数)
		hgsetreq SYSREQ_DSGLOBAL,1	; フォーカス外でもサウンドを再生するフラグ(1=ON,0=OFF)
		hgsetreq SYSREQ_DSSOFTWARE,1	; ソフトウェアバッファを使用するフラグ(1=ON,0=OFF)
		dmmini


・デバイスロストについて

	HGIMG3が使用しているDirectXは、コンピューターのスリープや、意図しない
	画面モードの変更によって、描画デバイスの消失(デバイスロスト)が発生する
	ことがあります。
	HGIMG3では、できる限りデバイスロストからの復旧を試みますが、
	復旧に失敗した場合は、画面の初期化するところからやり直す必要が出てきます。
	通常の使用でデバイスロストが発生することはありませんが、
	不慮の動作に備えて、デバイスロストに対応することで、より親切なソフトを
	作成することができます。
	デバイスロストを検知するには、hggetreq命令によりSYSREQ_DEVLOSTの値を
	取得してください。この値が、0以外の場合はデバイスロストが発生しています。

		hgini
	*main
		hggetreq devlost,SYSREQ_DEVLOST
		if devlost : goto *lost
		hgdraw				; 描画
		hgsync 16
		goto *main
	*lost
		;	デバイスロストが発生した
		hgini
		;	〜 必要な初期化の処理 〜
		goto *main

	上のように、描画の直前にデバイスロストの確認を行ない、
	初期化が必要な場合は適宜、プログラムを記述するようにしてください。


・HGIMG3対応ツールについて

	HGIMG3に対応した3Dツールとして以下のものを推奨しています。
	これ以外にも、x形式、mx形式を扱うツールを利用することが可能です。

	[3DACE の部屋]
	http://hp.vector.co.jp/authors/VA017881/

	直感的に3Dのモデリングを行うことのできるフリーソフト3DACEが公開されて
	います。MX形式、X形式での出力に対応しています。

	[metaseq.net]
	http://www.metaseq.net/

	Metasequoiaは、O.Miznoさんが作られた3Dモデリングツールです。
	フリー版のMetasequoiaLEは、オンラインですぐに入手することができ、
	3Dデータの作成を行ないx形式で出力することが可能です。
	Metasequoia自身や、プラグインでかなり多種のフォーマット読み込みに
	対応しているため既存の3Dファイルからの変換の可能性がぐんと広がります。


-------------------------------------------------------------------------------
                                                HSP users manual / end of file 
-------------------------------------------------------------------------------
